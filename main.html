<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>物理沙盒模拟器</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #f8f9fa;
            color: #212529;
            line-height: 1.6;
            overflow-x: hidden;
        }

        .visual-weaving-field {
            max-width: 1400px;
            margin: 0 auto;
            padding: 2rem;
        }

        header {
            text-align: center;
            margin-bottom: 2rem;
            padding: 1rem;
        }

        h1 {
            font-size: 2.5rem;
            font-weight: 700;
            color: #2c3e50;
            margin-bottom: 0.5rem;
        }

        .subtitle {
            font-size: 1.1rem;
            color: #7f8c8d;
            max-width: 600px;
            margin: 0 auto;
        }

        .simulation-container {
            display: grid;
            grid-template-columns: 300px 1fr;
            gap: 2rem;
            margin-bottom: 2rem;
        }

        .controls-panel {
            background: white;
            border-radius: 12px;
            padding: 1.5rem;
            box-shadow: 0 4px 20px rgba(0,0,0,0.08);
            height: fit-content;
        }

        .control-section {
            margin-bottom: 1.5rem;
        }

        .control-section h3 {
            font-size: 1.2rem;
            font-weight: 600;
            margin-bottom: 1rem;
            color: #34495e;
        }

        .element-buttons {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 0.75rem;
        }

        .element-button {
            padding: 0.75rem;
            border: none;
            border-radius: 8px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .element-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }

        .element-button.active {
            transform: scale(0.95);
            box-shadow: inset 0 2px 8px rgba(0,0,0,0.2);
        }

        .water { background: linear-gradient(135deg, #3498db, #2980b9); color: white; }
        .sand { background: linear-gradient(135deg, #f39c12, #e67e22); color: white; }
        .stone { background: linear-gradient(135deg, #95a5a6, #7f8c8d); color: white; }
        .wood { background: linear-gradient(135deg, #8b4513, #a0522d); color: white; }
        .fire { background: linear-gradient(135deg, #e74c3c, #c0392b); color: white; }
        .steam { background: linear-gradient(135deg, #bdc3c7, #ecf0f1); color: #2c3e50; }

        .canvas-wrapper {
            background: white;
            border-radius: 12px;
            padding: 1rem;
            box-shadow: 0 4px 20px rgba(0,0,0,0.08);
        }

        #physicsCanvas {
            border: 1px solid #ddd;
            border-radius: 8px;
            background: #1a1a2e;
            display: block;
            margin: 0 auto;
        }

        .info-panel {
            background: white;
            border-radius: 12px;
            padding: 1.5rem;
            box-shadow: 0 4px 20px rgba(0,0,0,0.08);
        }

        .info-panel h2 {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 1rem;
            color: #2c3e50;
        }

        .physics-rules {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 1.5rem;
            margin-top: 1rem;
        }

        .rule-card {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 1rem;
            border-left: 4px solid #3498db;
        }

        .rule-card h4 {
            font-weight: 600;
            margin-bottom: 0.5rem;
            color: #34495e;
        }

        .rule-card p {
            font-size: 0.9rem;
            color: #7f8c8d;
        }

        footer {
            text-align: center;
            padding: 2rem;
            color: #7f8c8d;
            font-size: 0.9rem;
        }

        @media (max-width: 768px) {
            .simulation-container {
                grid-template-columns: 1fr;
            }
            
            .element-buttons {
                grid-template-columns: repeat(3, 1fr);
            }
        }
    </style>
</head>
<body>
    <div class="visual-weaving-field">
        <header>
            <h1>物理沙盒模拟器</h1>
            <p class="subtitle">探索2D物理世界的奇妙互动 - 水、沙、石、木、火的动态模拟</p>
        </header>

        <div class="simulation-container">
            <div class="controls-panel">
                <div class="control-section">
                    <h3>选择元素</h3>
                    <div class="element-buttons">
                        <button class="element-button water" data-element="water">
                            <div>💧</div>
                            <span>水</span>
                        </button>
                        <button class="element-button sand" data-element="sand">
                            <div>🌾</div>
                            <span>沙子</span>
                        </button>
                        <button class="element-button stone" data-element="stone">
                            <div>🪨</div>
                            <span>石头</span>
                        </button>
                        <button class="element-button wood" data-element="wood">
                            <div>🪵</div>
                            <span>木材</span>
                        </button>
                        <button class="element-button fire" data-element="fire">
                            <div>🔥</div>
                            <span>火焰</span>
                        </button>
                        <button class="element-button steam" data-element="steam">
                            <div>☁️</div>
                            <span>蒸汽</span>
                        </button>
                    </div>
                </div>

                <div class="control-section">
                    <h3>操作控制</h3>
                    <button class="element-button" style="background: #9b59b6; color: white; grid-column: span 2;" id="clearButton">
                        🧹 清除画布
                    </button>
                </div>

                <div class="control-section">
                    <h3>物理参数</h3>
                    <div style="background: #f8f9fa; padding: 1rem; border-radius: 8px;">
                        <p>重力强度: <span id="gravityValue">0.5</span></p>
                        <input type="range" id="gravitySlider" min="0" max="1" step="0.1" value="0.5" style="width: 100%;">
                        <p style="margin-top: 1rem;">粒子大小: <span id="particleSizeValue">3</span>px</p>
                        <input type="range" id="particleSizeSlider" min="1" max="4" step="1" value="3" style="width: 100%;">
                    </div>
                </div>
            </div>

            <div class="canvas-wrapper">
                <canvas id="physicsCanvas" width="800" height="600"></canvas>
            </div>
        </div>

        <div class="info-panel">
            <h2>物理规则说明</h2>
            <div class="physics-rules">
                <div class="rule-card">
                    <h4>💧 水</h4>
                    <p>受重力影响向下流动，遇火蒸发成蒸汽，可被木材阻挡</p>
                </div>
                <div class="rule-card">
                    <h4>🌾 沙子</h4>
                    <p>受重力影响，可堆积形成斜坡，遇火燃烧成木材</p>
                </div>
                <div class="rule-card">
                    <h4>🪨 石头</h4>
                    <p>不受重力影响，固定不动，可作为其他元素的障碍物</p>
                </div>
                <div class="rule-card">
                    <h4>🪵 木材</h4>
                    <p>不受重力影响，固定不动，遇火燃烧消失</p>
                </div>
                <div class="rule-card">
                    <h4>🔥 火焰</h4>
                    <p>向上燃烧，可点燃木材，使水蒸发，有生命周期</p>
                </div>
                <div class="rule-card">
                    <h4>☁️ 蒸汽</h4>
                    <p>向上飘散，遇冷凝结回水，具有扩散性</p>
                </div>
            </div>
        </div>

        <footer>
            <p>物理沙盒模拟器 | 真实物理效应：重力、流体动力学、热传导、状态变化</p>
        </footer>
    </div>

    <script>
        // 粒子系统配置
        const config = {
            gravity: 0.5,
            particleSize: 3,
            canvasWidth: 800,
            canvasHeight: 600,
            gridWidth: 800,
            gridHeight: 600
        };

        // 元素类型定义
        const ELEMENT_TYPES = {
            EMPTY: 0,
            SAND: 1,
            WATER: 2,
            STONE: 3,
            WOOD: 4,
            FIRE: 5,
            STEAM: 6
        };

        // 元素颜色映射
        const ELEMENT_COLORS = {
            [ELEMENT_TYPES.EMPTY]: '#1a1a2e',
            [ELEMENT_TYPES.SAND]: '#f39c12',
            [ELEMENT_TYPES.WATER]: '#3498db',
            [ELEMENT_TYPES.STONE]: '#95a5a6',
            [ELEMENT_TYPES.WOOD]: '#8b4513',
            [ELEMENT_TYPES.FIRE]: '#e74c3c',
            [ELEMENT_TYPES.STEAM]: '#ecf0f1'
        };

        // 元素名称映射
        const ELEMENT_NAMES = {
            [ELEMENT_TYPES.EMPTY]: '空',
            [ELEMENT_TYPES.SAND]: '沙子',
            [ELEMENT_TYPES.WATER]: '水',
            [ELEMENT_TYPES.STONE]: '石头',
            [ELEMENT_TYPES.WOOD]: '木材',
            [ELEMENT_TYPES.FIRE]: '火焰',
            [ELEMENT_TYPES.STEAM]: '蒸汽'
        };

        // 当前选中元素
        let currentElement = ELEMENT_TYPES.SAND;
        let isMouseDown = false;
        let lastX, lastY;

        // 初始化网格
        let grid = [];
        for (let i = 0; i < config.gridWidth; i++) {
            grid[i] = new Array(config.gridHeight).fill(ELEMENT_TYPES.EMPTY);
        }

        // 获取Canvas元素
        const canvas = document.getElementById('physicsCanvas');
        const ctx = canvas.getContext('2d');

        // 设置UI交互
        document.querySelectorAll('.element-button').forEach(button => {
            button.addEventListener('click', () => {
                document.querySelectorAll('.element-button').forEach(btn => btn.classList.remove('active'));
                button.classList.add('active');
                currentElement = ELEMENT_TYPES[button.dataset.element.toUpperCase()];
            });
        });

        document.getElementById('clearButton').addEventListener('click', () => {
            for (let i = 0; i < config.gridWidth; i++) {
                grid[i] = new Array(config.gridHeight).fill(ELEMENT_TYPES.EMPTY);
            }
            drawGrid();
        });

        document.getElementById('gravitySlider').addEventListener('input', (e) => {
            config.gravity = parseFloat(e.target.value);
            document.getElementById('gravityValue').textContent = config.gravity;
        });

        document.getElementById('particleSizeSlider').addEventListener('input', (e) => {
            config.particleSize = parseInt(e.target.value);
            document.getElementById('particleSizeValue').textContent = config.particleSize;
        });

        // 鼠标事件处理
        canvas.addEventListener('mousedown', (e) => {
            isMouseDown = true;
            const rect = canvas.getBoundingClientRect();
            const x = Math.floor((e.clientX - rect.left) / config.particleSize);
            const y = Math.floor((e.clientY - rect.top) / config.particleSize);
            addElement(x, y);
            lastX = x;
            lastY = y;
        });

        canvas.addEventListener('mousemove', (e) => {
            if (isMouseDown) {
                const rect = canvas.getBoundingClientRect();
                const x = Math.floor((e.clientX - rect.left) / config.particleSize);
                const y = Math.floor((e.clientY - rect.top) / config.particleSize);
                
                // 绘制线条连接点
                if (lastX !== undefined && lastY !== undefined) {
                    drawLine(lastX, lastY, x, y);
                }
                
                addElement(x, y);
                lastX = x;
                lastY = y;
            }
        });

        canvas.addEventListener('mouseup', () => {
            isMouseDown = false;
            lastX = undefined;
            lastY = undefined;
        });

        canvas.addEventListener('mouseleave', () => {
            isMouseDown = false;
            lastX = undefined;
            lastY = undefined;
        });

        // 绘制线条函数
        function drawLine(x0, y0, x1, y1) {
            const dx = Math.abs(x1 - x0);
            const dy = Math.abs(y1 - y0);
            const sx = (x0 < x1) ? 1 : -1;
            const sy = (y0 < y1) ? 1 : -1;
            let err = dx - dy;
            
            while (true) {
                addElement(x0, y0);
                
                if (x0 === x1 && y0 === y1) break;
                const e2 = 2 * err;
                if (e2 > -dy) {
                    err -= dy;
                    x0 += sx;
                }
                if (e2 < dx) {
                    err += dx;
                    y0 += sy;
                }
            }
        }

        // 添加元素到网格
        function addElement(x, y) {
            if (x >= 0 && x < config.gridWidth && y >= 0 && y < config.gridHeight) {
                // 添加元素时考虑粒子大小
                const radius = Math.floor(config.particleSize / 2);
                for (let i = -radius; i <= radius; i++) {
                    for (let j = -radius; j <= radius; j++) {
                        const nx = x + i;
                        const ny = y + j;
                        if (nx >= 0 && nx < config.gridWidth && ny >= 0 && ny < config.gridHeight) {
                            if (Math.random() > 0.3) { // 随机填充以创建更自然的效果
                                grid[nx][ny] = currentElement;
                            }
                        }
                    }
                }
            }
        }

        // 物理更新函数
        function updatePhysics() {
            // 从下往上，从左往右更新
            for (let y = config.gridHeight - 2; y >= 0; y--) {
                for (let x = 0; x < config.gridWidth; x++) {
                    const element = grid[x][y];
                    
                    switch (element) {
                        case ELEMENT_TYPES.SAND:
                            updateSand(x, y);
                            break;
                        case ELEMENT_TYPES.WATER:
                            updateWater(x, y);
                            break;
                        case ELEMENT_TYPES.FIRE:
                            updateFire(x, y);
                            break;
                        case ELEMENT_TYPES.STEAM:
                            updateSteam(x, y);
                            break;
                    }
                }
            }
        }

        // 沙子物理更新
        function updateSand(x, y) {
            // 直接下方为空
            if (y + 1 < config.gridHeight && grid[x][y + 1] === ELEMENT_TYPES.EMPTY) {
                grid[x][y] = ELEMENT_TYPES.EMPTY;
                grid[x][y + 1] = ELEMENT_TYPES.SAND;
                return;
            }
            
            // 下方为水，则下沉
            if (y + 1 < config.gridHeight && grid[x][y + 1] === ELEMENT_TYPES.WATER) {
                grid[x][y] = ELEMENT_TYPES.WATER;
                grid[x][y + 1] = ELEMENT_TYPES.SAND;
                return;
            }
            
            // 左下或右下为空（随机选择方向以避免偏向）
            const dir = Math.random() > 0.5 ? 1 : -1;
            if (y + 1 < config.gridHeight) {
                if (x + dir >= 0 && x + dir < config.gridWidth && grid[x + dir][y + 1] === ELEMENT_TYPES.EMPTY) {
                    grid[x][y] = ELEMENT_TYPES.EMPTY;
                    grid[x + dir][y + 1] = ELEMENT_TYPES.SAND;
                    return;
                }
                if (x - dir >= 0 && x - dir < config.gridWidth && grid[x - dir][y + 1] === ELEMENT_TYPES.EMPTY) {
                    grid[x][y] = ELEMENT_TYPES.EMPTY;
                    grid[x - dir][y + 1] = ELEMENT_TYPES.SAND;
                    return;
                }
            }
        }

        // 水物理更新
        function updateWater(x, y) {
            // 直接下方为空或为蒸汽
            if (y + 1 < config.gridHeight && (grid[x][y + 1] === ELEMENT_TYPES.EMPTY || grid[x][y + 1] === ELEMENT_TYPES.STEAM)) {
                grid[x][y] = grid[x][y + 1];
                grid[x][y + 1] = ELEMENT_TYPES.WATER;
                return;
            }
            
            // 左下或右下为空
            const dir = Math.random() > 0.5 ? 1 : -1;
            if (y + 1 < config.gridHeight) {
                if (x + dir >= 0 && x + dir < config.gridWidth && grid[x + dir][y + 1] === ELEMENT_TYPES.EMPTY) {
                    grid[x][y] = ELEMENT_TYPES.EMPTY;
                    grid[x + dir][y + 1] = ELEMENT_TYPES.WATER;
                    return;
                }
                if (x - dir >= 0 && x - dir < config.gridWidth && grid[x - dir][y + 1] === ELEMENT_TYPES.EMPTY) {
                    grid[x][y] = ELEMENT_TYPES.EMPTY;
                    grid[x - dir][y + 1] = ELEMENT_TYPES.WATER;
                    return;
                }
            }
            
            // 侧向流动
            if (Math.random() > 0.5) {
                if (x + 1 < config.gridWidth && grid[x + 1][y] === ELEMENT_TYPES.EMPTY) {
                    grid[x][y] = ELEMENT_TYPES.EMPTY;
                    grid[x + 1][y] = ELEMENT_TYPES.WATER;
                    return;
                }
            } else {
                if (x - 1 >= 0 && grid[x - 1][y] === ELEMENT_TYPES.EMPTY) {
                    grid[x][y] = ELEMENT_TYPES.EMPTY;
                    grid[x - 1][y] = ELEMENT_TYPES.WATER;
                    return;
                }
            }
        }

        // 火焰物理更新
        function updateFire(x, y) {
            // 火焰有生命周期，随机消失
            if (Math.random() < 0.05) {
                grid[x][y] = ELEMENT_TYPES.EMPTY;
                return;
            }
            
            // 向上飘散
            if (y - 1 >= 0 && grid[x][y - 1] === ELEMENT_TYPES.EMPTY) {
                grid[x][y] = ELEMENT_TYPES.EMPTY;
                grid[x][y - 1] = ELEMENT_TYPES.FIRE;
                return;
            }
            
            // 随机侧向移动
            if (Math.random() < 0.3) {
                const dir = Math.random() > 0.5 ? 1 : -1;
                if (x + dir >= 0 && x + dir < config.gridWidth && grid[x + dir][y] === ELEMENT_TYPES.EMPTY) {
                    grid[x][y] = ELEMENT_TYPES.EMPTY;
                    grid[x + dir][y] = ELEMENT_TYPES.FIRE;
                    return;
                }
            }
            
            // 与周围元素交互
            for (let dx = -1; dx <= 1; dx++) {
                for (let dy = -1; dy <= 1; dy++) {
                    const nx = x + dx;
                    const ny = y + dy;
                    if (nx >= 0 && nx < config.gridWidth && ny >= 0 && ny < config.gridHeight) {
                        // 遇水蒸发
                        if (grid[nx][ny] === ELEMENT_TYPES.WATER && Math.random() < 0.2) {
                            grid[nx][ny] = ELEMENT_TYPES.STEAM;
                        }
                        // 点燃木材
                        else if (grid[nx][ny] === ELEMENT_TYPES.WOOD && Math.random() < 0.1) {
                            grid[nx][ny] = ELEMENT_TYPES.FIRE;
                        }
                        // 火焰扩散
                        else if (grid[nx][ny] === ELEMENT_TYPES.EMPTY && Math.random() < 0.05) {
                            grid[nx][ny] = ELEMENT_TYPES.FIRE;
                        }
                    }
                }
            }
        }

        // 蒸汽物理更新
        function updateSteam(x, y) {
            // 蒸汽向上飘散
            if (y - 1 >= 0 && grid[x][y - 1] === ELEMENT_TYPES.EMPTY) {
                grid[x][y] = ELEMENT_TYPES.EMPTY;
                grid[x][y - 1] = ELEMENT_TYPES.STEAM;
                return;
            }
            
            // 随机侧向扩散
            if (Math.random() < 0.2) {
                const dir = Math.random() > 0.5 ? 1 : -1;
                if (x + dir >= 0 && x + dir < config.gridWidth && grid[x + dir][y] === ELEMENT_TYPES.EMPTY) {
                    grid[x][y] = ELEMENT_TYPES.EMPTY;
                    grid[x + dir][y] = ELEMENT_TYPES.STEAM;
                    return;
                }
            }
            
            // 遇冷凝结（边缘区域）
            if (x === 0 || x === config.gridWidth - 1 || y === 0 || y === config.gridHeight - 1) {
                if (Math.random() < 0.02) {
                    grid[x][y] = ELEMENT_TYPES.WATER;
                }
            }
        }

        // 绘制网格
        function drawGrid() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            for (let x = 0; x < config.gridWidth; x++) {
                for (let y = 0; y < config.gridHeight; y++) {
                    const element = grid[x][y];
                    if (element !== ELEMENT_TYPES.EMPTY) {
                        ctx.fillStyle = ELEMENT_COLORS[element];
                        ctx.fillRect(
                            x * config.particleSize, 
                            y * config.particleSize, 
                            config.particleSize, 
                            config.particleSize
                        );
                    }
                }
            }
        }

        // 主动画循环
        function animate() {
            updatePhysics();
            drawGrid();
            requestAnimationFrame(animate);
        }

        // 初始化
        function init() {
            // 设置默认激活按钮
            document.querySelector('.element-button[data-element="sand"]').classList.add('active');
            
            // 绘制初始网格
            drawGrid();
            
            // 开始动画
            animate();
        }

        // 启动模拟
        window.addEventListener('load', init);
    </script>
</body>
</html>
