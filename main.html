<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç‰©ç†æ²™ç›’æ¨¡æ‹Ÿå™¨</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #f8f9fa;
            color: #212529;
            line-height: 1.6;
            overflow-x: hidden;
        }

        .visual-weaving-field {
            max-width: 1400px;
            margin: 0 auto;
            padding: 2rem;
        }

        header {
            text-align: center;
            margin-bottom: 2rem;
            padding: 1rem;
        }

        h1 {
            font-size: 2.5rem;
            font-weight: 700;
            color: #2c3e50;
            margin-bottom: 0.5rem;
        }

        .subtitle {
            font-size: 1.1rem;
            color: #7f8c8d;
            max-width: 600px;
            margin: 0 auto;
        }

        .simulation-container {
            display: grid;
            grid-template-columns: 300px 1fr;
            gap: 2rem;
            margin-bottom: 2rem;
        }

        .controls-panel {
            background: white;
            border-radius: 12px;
            padding: 1.5rem;
            box-shadow: 0 4px 20px rgba(0,0,0,0.08);
            height: fit-content;
        }

        .control-section {
            margin-bottom: 1.5rem;
        }

        .control-section h3 {
            font-size: 1.2rem;
            font-weight: 600;
            margin-bottom: 1rem;
            color: #34495e;
        }

        .element-buttons {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 0.75rem;
        }

        .element-button {
            padding: 0.75rem;
            border: none;
            border-radius: 8px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .element-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }

        .element-button.active {
            transform: scale(0.95);
            box-shadow: inset 0 2px 8px rgba(0,0,0,0.2);
        }

        .water { background: linear-gradient(135deg, #3498db, #2980b9); color: white; }
        .sand { background: linear-gradient(135deg, #f39c12, #e67e22); color: white; }
        .stone { background: linear-gradient(135deg, #95a5a6, #7f8c8d); color: white; }
        .wood { background: linear-gradient(135deg, #8b4513, #a0522d); color: white; }
        .fire { background: linear-gradient(135deg, #e74c3c, #c0392b); color: white; }
        .steam { background: linear-gradient(135deg, #bdc3c7, #ecf0f1); color: #2c3e50; }

        .canvas-wrapper {
            background: white;
            border-radius: 12px;
            padding: 1rem;
            box-shadow: 0 4px 20px rgba(0,0,0,0.08);
        }

        #physicsCanvas {
            border: 1px solid #ddd;
            border-radius: 8px;
            background: #1a1a2e;
            display: block;
            margin: 0 auto;
        }

        .info-panel {
            background: white;
            border-radius: 12px;
            padding: 1.5rem;
            box-shadow: 0 4px 20px rgba(0,0,0,0.08);
        }

        .info-panel h2 {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 1rem;
            color: #2c3e50;
        }

        .physics-rules {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 1.5rem;
            margin-top: 1rem;
        }

        .rule-card {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 1rem;
            border-left: 4px solid #3498db;
        }

        .rule-card h4 {
            font-weight: 600;
            margin-bottom: 0.5rem;
            color: #34495e;
        }

        .rule-card p {
            font-size: 0.9rem;
            color: #7f8c8d;
        }

        footer {
            text-align: center;
            padding: 2rem;
            color: #7f8c8d;
            font-size: 0.9rem;
        }

        @media (max-width: 768px) {
            .simulation-container {
                grid-template-columns: 1fr;
            }
            
            .element-buttons {
                grid-template-columns: repeat(3, 1fr);
            }
        }
    </style>
</head>
<body>
    <div class="visual-weaving-field">
        <header>
            <h1>ç‰©ç†æ²™ç›’æ¨¡æ‹Ÿå™¨</h1>
            <p class="subtitle">æ¢ç´¢2Dç‰©ç†ä¸–ç•Œçš„å¥‡å¦™äº’åŠ¨ - æ°´ã€æ²™ã€çŸ³ã€æœ¨ã€ç«çš„åŠ¨æ€æ¨¡æ‹Ÿ</p>
        </header>

        <div class="simulation-container">
            <div class="controls-panel">
                <div class="control-section">
                    <h3>é€‰æ‹©å…ƒç´ </h3>
                    <div class="element-buttons">
                        <button class="element-button water" data-element="water">
                            <div>ğŸ’§</div>
                            <span>æ°´</span>
                        </button>
                        <button class="element-button sand" data-element="sand">
                            <div>ğŸŒ¾</div>
                            <span>æ²™å­</span>
                        </button>
                        <button class="element-button stone" data-element="stone">
                            <div>ğŸª¨</div>
                            <span>çŸ³å¤´</span>
                        </button>
                        <button class="element-button wood" data-element="wood">
                            <div>ğŸªµ</div>
                            <span>æœ¨æ</span>
                        </button>
                        <button class="element-button fire" data-element="fire">
                            <div>ğŸ”¥</div>
                            <span>ç«ç„°</span>
                        </button>
                        <button class="element-button steam" data-element="steam">
                            <div>â˜ï¸</div>
                            <span>è’¸æ±½</span>
                        </button>
                    </div>
                </div>

                <div class="control-section">
                    <h3>æ“ä½œæ§åˆ¶</h3>
                    <button class="element-button" style="background: #9b59b6; color: white; grid-column: span 2;" id="clearButton">
                        ğŸ§¹ æ¸…é™¤ç”»å¸ƒ
                    </button>
                </div>

                <div class="control-section">
                    <h3>ç‰©ç†å‚æ•°</h3>
                    <div style="background: #f8f9fa; padding: 1rem; border-radius: 8px;">
                        <p>é‡åŠ›å¼ºåº¦: <span id="gravityValue">0.5</span></p>
                        <input type="range" id="gravitySlider" min="0" max="1" step="0.1" value="0.5" style="width: 100%;">
                        <p style="margin-top: 1rem;">ç²’å­å¤§å°: <span id="particleSizeValue">3</span>px</p>
                        <input type="range" id="particleSizeSlider" min="1" max="4" step="1" value="3" style="width: 100%;">
                    </div>
                </div>
            </div>

            <div class="canvas-wrapper">
                <canvas id="physicsCanvas" width="800" height="600"></canvas>
            </div>
        </div>

        <div class="info-panel">
            <h2>ç‰©ç†è§„åˆ™è¯´æ˜</h2>
            <div class="physics-rules">
                <div class="rule-card">
                    <h4>ğŸ’§ æ°´</h4>
                    <p>å—é‡åŠ›å½±å“å‘ä¸‹æµåŠ¨ï¼Œé‡ç«è’¸å‘æˆè’¸æ±½ï¼Œå¯è¢«æœ¨æé˜»æŒ¡</p>
                </div>
                <div class="rule-card">
                    <h4>ğŸŒ¾ æ²™å­</h4>
                    <p>å—é‡åŠ›å½±å“ï¼Œå¯å †ç§¯å½¢æˆæ–œå¡ï¼Œé‡ç«ç‡ƒçƒ§æˆæœ¨æ</p>
                </div>
                <div class="rule-card">
                    <h4>ğŸª¨ çŸ³å¤´</h4>
                    <p>ä¸å—é‡åŠ›å½±å“ï¼Œå›ºå®šä¸åŠ¨ï¼Œå¯ä½œä¸ºå…¶ä»–å…ƒç´ çš„éšœç¢ç‰©</p>
                </div>
                <div class="rule-card">
                    <h4>ğŸªµ æœ¨æ</h4>
                    <p>ä¸å—é‡åŠ›å½±å“ï¼Œå›ºå®šä¸åŠ¨ï¼Œé‡ç«ç‡ƒçƒ§æ¶ˆå¤±</p>
                </div>
                <div class="rule-card">
                    <h4>ğŸ”¥ ç«ç„°</h4>
                    <p>å‘ä¸Šç‡ƒçƒ§ï¼Œå¯ç‚¹ç‡ƒæœ¨æï¼Œä½¿æ°´è’¸å‘ï¼Œæœ‰ç”Ÿå‘½å‘¨æœŸ</p>
                </div>
                <div class="rule-card">
                    <h4>â˜ï¸ è’¸æ±½</h4>
                    <p>å‘ä¸Šé£˜æ•£ï¼Œé‡å†·å‡ç»“å›æ°´ï¼Œå…·æœ‰æ‰©æ•£æ€§</p>
                </div>
            </div>
        </div>

        <footer>
            <p>ç‰©ç†æ²™ç›’æ¨¡æ‹Ÿå™¨ | çœŸå®ç‰©ç†æ•ˆåº”ï¼šé‡åŠ›ã€æµä½“åŠ¨åŠ›å­¦ã€çƒ­ä¼ å¯¼ã€çŠ¶æ€å˜åŒ–</p>
        </footer>
    </div>

    <script>
        // ç²’å­ç³»ç»Ÿé…ç½®
        const config = {
            gravity: 0.5,
            particleSize: 3,
            canvasWidth: 800,
            canvasHeight: 600,
            gridWidth: 800,
            gridHeight: 600
        };

        // å…ƒç´ ç±»å‹å®šä¹‰
        const ELEMENT_TYPES = {
            EMPTY: 0,
            SAND: 1,
            WATER: 2,
            STONE: 3,
            WOOD: 4,
            FIRE: 5,
            STEAM: 6
        };

        // å…ƒç´ é¢œè‰²æ˜ å°„
        const ELEMENT_COLORS = {
            [ELEMENT_TYPES.EMPTY]: '#1a1a2e',
            [ELEMENT_TYPES.SAND]: '#f39c12',
            [ELEMENT_TYPES.WATER]: '#3498db',
            [ELEMENT_TYPES.STONE]: '#95a5a6',
            [ELEMENT_TYPES.WOOD]: '#8b4513',
            [ELEMENT_TYPES.FIRE]: '#e74c3c',
            [ELEMENT_TYPES.STEAM]: '#ecf0f1'
        };

        // å…ƒç´ åç§°æ˜ å°„
        const ELEMENT_NAMES = {
            [ELEMENT_TYPES.EMPTY]: 'ç©º',
            [ELEMENT_TYPES.SAND]: 'æ²™å­',
            [ELEMENT_TYPES.WATER]: 'æ°´',
            [ELEMENT_TYPES.STONE]: 'çŸ³å¤´',
            [ELEMENT_TYPES.WOOD]: 'æœ¨æ',
            [ELEMENT_TYPES.FIRE]: 'ç«ç„°',
            [ELEMENT_TYPES.STEAM]: 'è’¸æ±½'
        };

        // å½“å‰é€‰ä¸­å…ƒç´ 
        let currentElement = ELEMENT_TYPES.SAND;
        let isMouseDown = false;
        let lastX, lastY;

        // åˆå§‹åŒ–ç½‘æ ¼
        let grid = [];
        for (let i = 0; i < config.gridWidth; i++) {
            grid[i] = new Array(config.gridHeight).fill(ELEMENT_TYPES.EMPTY);
        }

        // è·å–Canvaså…ƒç´ 
        const canvas = document.getElementById('physicsCanvas');
        const ctx = canvas.getContext('2d');

        // è®¾ç½®UIäº¤äº’
        document.querySelectorAll('.element-button').forEach(button => {
            button.addEventListener('click', () => {
                document.querySelectorAll('.element-button').forEach(btn => btn.classList.remove('active'));
                button.classList.add('active');
                currentElement = ELEMENT_TYPES[button.dataset.element.toUpperCase()];
            });
        });

        document.getElementById('clearButton').addEventListener('click', () => {
            for (let i = 0; i < config.gridWidth; i++) {
                grid[i] = new Array(config.gridHeight).fill(ELEMENT_TYPES.EMPTY);
            }
            drawGrid();
        });

        document.getElementById('gravitySlider').addEventListener('input', (e) => {
            config.gravity = parseFloat(e.target.value);
            document.getElementById('gravityValue').textContent = config.gravity;
        });

        document.getElementById('particleSizeSlider').addEventListener('input', (e) => {
            config.particleSize = parseInt(e.target.value);
            document.getElementById('particleSizeValue').textContent = config.particleSize;
        });

        // é¼ æ ‡äº‹ä»¶å¤„ç†
        canvas.addEventListener('mousedown', (e) => {
            isMouseDown = true;
            const rect = canvas.getBoundingClientRect();
            const x = Math.floor((e.clientX - rect.left) / config.particleSize);
            const y = Math.floor((e.clientY - rect.top) / config.particleSize);
            addElement(x, y);
            lastX = x;
            lastY = y;
        });

        canvas.addEventListener('mousemove', (e) => {
            if (isMouseDown) {
                const rect = canvas.getBoundingClientRect();
                const x = Math.floor((e.clientX - rect.left) / config.particleSize);
                const y = Math.floor((e.clientY - rect.top) / config.particleSize);
                
                // ç»˜åˆ¶çº¿æ¡è¿æ¥ç‚¹
                if (lastX !== undefined && lastY !== undefined) {
                    drawLine(lastX, lastY, x, y);
                }
                
                addElement(x, y);
                lastX = x;
                lastY = y;
            }
        });

        canvas.addEventListener('mouseup', () => {
            isMouseDown = false;
            lastX = undefined;
            lastY = undefined;
        });

        canvas.addEventListener('mouseleave', () => {
            isMouseDown = false;
            lastX = undefined;
            lastY = undefined;
        });

        // ç»˜åˆ¶çº¿æ¡å‡½æ•°
        function drawLine(x0, y0, x1, y1) {
            const dx = Math.abs(x1 - x0);
            const dy = Math.abs(y1 - y0);
            const sx = (x0 < x1) ? 1 : -1;
            const sy = (y0 < y1) ? 1 : -1;
            let err = dx - dy;
            
            while (true) {
                addElement(x0, y0);
                
                if (x0 === x1 && y0 === y1) break;
                const e2 = 2 * err;
                if (e2 > -dy) {
                    err -= dy;
                    x0 += sx;
                }
                if (e2 < dx) {
                    err += dx;
                    y0 += sy;
                }
            }
        }

        // æ·»åŠ å…ƒç´ åˆ°ç½‘æ ¼
        function addElement(x, y) {
            if (x >= 0 && x < config.gridWidth && y >= 0 && y < config.gridHeight) {
                // æ·»åŠ å…ƒç´ æ—¶è€ƒè™‘ç²’å­å¤§å°
                const radius = Math.floor(config.particleSize / 2);
                for (let i = -radius; i <= radius; i++) {
                    for (let j = -radius; j <= radius; j++) {
                        const nx = x + i;
                        const ny = y + j;
                        if (nx >= 0 && nx < config.gridWidth && ny >= 0 && ny < config.gridHeight) {
                            if (Math.random() > 0.3) { // éšæœºå¡«å……ä»¥åˆ›å»ºæ›´è‡ªç„¶çš„æ•ˆæœ
                                grid[nx][ny] = currentElement;
                            }
                        }
                    }
                }
            }
        }

        // ç‰©ç†æ›´æ–°å‡½æ•°
        function updatePhysics() {
            // ä»ä¸‹å¾€ä¸Šï¼Œä»å·¦å¾€å³æ›´æ–°
            for (let y = config.gridHeight - 2; y >= 0; y--) {
                for (let x = 0; x < config.gridWidth; x++) {
                    const element = grid[x][y];
                    
                    switch (element) {
                        case ELEMENT_TYPES.SAND:
                            updateSand(x, y);
                            break;
                        case ELEMENT_TYPES.WATER:
                            updateWater(x, y);
                            break;
                        case ELEMENT_TYPES.FIRE:
                            updateFire(x, y);
                            break;
                        case ELEMENT_TYPES.STEAM:
                            updateSteam(x, y);
                            break;
                    }
                }
            }
        }

        // æ²™å­ç‰©ç†æ›´æ–°
        function updateSand(x, y) {
            // ç›´æ¥ä¸‹æ–¹ä¸ºç©º
            if (y + 1 < config.gridHeight && grid[x][y + 1] === ELEMENT_TYPES.EMPTY) {
                grid[x][y] = ELEMENT_TYPES.EMPTY;
                grid[x][y + 1] = ELEMENT_TYPES.SAND;
                return;
            }
            
            // ä¸‹æ–¹ä¸ºæ°´ï¼Œåˆ™ä¸‹æ²‰
            if (y + 1 < config.gridHeight && grid[x][y + 1] === ELEMENT_TYPES.WATER) {
                grid[x][y] = ELEMENT_TYPES.WATER;
                grid[x][y + 1] = ELEMENT_TYPES.SAND;
                return;
            }
            
            // å·¦ä¸‹æˆ–å³ä¸‹ä¸ºç©ºï¼ˆéšæœºé€‰æ‹©æ–¹å‘ä»¥é¿å…åå‘ï¼‰
            const dir = Math.random() > 0.5 ? 1 : -1;
            if (y + 1 < config.gridHeight) {
                if (x + dir >= 0 && x + dir < config.gridWidth && grid[x + dir][y + 1] === ELEMENT_TYPES.EMPTY) {
                    grid[x][y] = ELEMENT_TYPES.EMPTY;
                    grid[x + dir][y + 1] = ELEMENT_TYPES.SAND;
                    return;
                }
                if (x - dir >= 0 && x - dir < config.gridWidth && grid[x - dir][y + 1] === ELEMENT_TYPES.EMPTY) {
                    grid[x][y] = ELEMENT_TYPES.EMPTY;
                    grid[x - dir][y + 1] = ELEMENT_TYPES.SAND;
                    return;
                }
            }
        }

        // æ°´ç‰©ç†æ›´æ–°
        function updateWater(x, y) {
            // ç›´æ¥ä¸‹æ–¹ä¸ºç©ºæˆ–ä¸ºè’¸æ±½
            if (y + 1 < config.gridHeight && (grid[x][y + 1] === ELEMENT_TYPES.EMPTY || grid[x][y + 1] === ELEMENT_TYPES.STEAM)) {
                grid[x][y] = grid[x][y + 1];
                grid[x][y + 1] = ELEMENT_TYPES.WATER;
                return;
            }
            
            // å·¦ä¸‹æˆ–å³ä¸‹ä¸ºç©º
            const dir = Math.random() > 0.5 ? 1 : -1;
            if (y + 1 < config.gridHeight) {
                if (x + dir >= 0 && x + dir < config.gridWidth && grid[x + dir][y + 1] === ELEMENT_TYPES.EMPTY) {
                    grid[x][y] = ELEMENT_TYPES.EMPTY;
                    grid[x + dir][y + 1] = ELEMENT_TYPES.WATER;
                    return;
                }
                if (x - dir >= 0 && x - dir < config.gridWidth && grid[x - dir][y + 1] === ELEMENT_TYPES.EMPTY) {
                    grid[x][y] = ELEMENT_TYPES.EMPTY;
                    grid[x - dir][y + 1] = ELEMENT_TYPES.WATER;
                    return;
                }
            }
            
            // ä¾§å‘æµåŠ¨
            if (Math.random() > 0.5) {
                if (x + 1 < config.gridWidth && grid[x + 1][y] === ELEMENT_TYPES.EMPTY) {
                    grid[x][y] = ELEMENT_TYPES.EMPTY;
                    grid[x + 1][y] = ELEMENT_TYPES.WATER;
                    return;
                }
            } else {
                if (x - 1 >= 0 && grid[x - 1][y] === ELEMENT_TYPES.EMPTY) {
                    grid[x][y] = ELEMENT_TYPES.EMPTY;
                    grid[x - 1][y] = ELEMENT_TYPES.WATER;
                    return;
                }
            }
        }

        // ç«ç„°ç‰©ç†æ›´æ–°
        function updateFire(x, y) {
            // ç«ç„°æœ‰ç”Ÿå‘½å‘¨æœŸï¼Œéšæœºæ¶ˆå¤±
            if (Math.random() < 0.05) {
                grid[x][y] = ELEMENT_TYPES.EMPTY;
                return;
            }
            
            // å‘ä¸Šé£˜æ•£
            if (y - 1 >= 0 && grid[x][y - 1] === ELEMENT_TYPES.EMPTY) {
                grid[x][y] = ELEMENT_TYPES.EMPTY;
                grid[x][y - 1] = ELEMENT_TYPES.FIRE;
                return;
            }
            
            // éšæœºä¾§å‘ç§»åŠ¨
            if (Math.random() < 0.3) {
                const dir = Math.random() > 0.5 ? 1 : -1;
                if (x + dir >= 0 && x + dir < config.gridWidth && grid[x + dir][y] === ELEMENT_TYPES.EMPTY) {
                    grid[x][y] = ELEMENT_TYPES.EMPTY;
                    grid[x + dir][y] = ELEMENT_TYPES.FIRE;
                    return;
                }
            }
            
            // ä¸å‘¨å›´å…ƒç´ äº¤äº’
            for (let dx = -1; dx <= 1; dx++) {
                for (let dy = -1; dy <= 1; dy++) {
                    const nx = x + dx;
                    const ny = y + dy;
                    if (nx >= 0 && nx < config.gridWidth && ny >= 0 && ny < config.gridHeight) {
                        // é‡æ°´è’¸å‘
                        if (grid[nx][ny] === ELEMENT_TYPES.WATER && Math.random() < 0.2) {
                            grid[nx][ny] = ELEMENT_TYPES.STEAM;
                        }
                        // ç‚¹ç‡ƒæœ¨æ
                        else if (grid[nx][ny] === ELEMENT_TYPES.WOOD && Math.random() < 0.1) {
                            grid[nx][ny] = ELEMENT_TYPES.FIRE;
                        }
                        // ç«ç„°æ‰©æ•£
                        else if (grid[nx][ny] === ELEMENT_TYPES.EMPTY && Math.random() < 0.05) {
                            grid[nx][ny] = ELEMENT_TYPES.FIRE;
                        }
                    }
                }
            }
        }

        // è’¸æ±½ç‰©ç†æ›´æ–°
        function updateSteam(x, y) {
            // è’¸æ±½å‘ä¸Šé£˜æ•£
            if (y - 1 >= 0 && grid[x][y - 1] === ELEMENT_TYPES.EMPTY) {
                grid[x][y] = ELEMENT_TYPES.EMPTY;
                grid[x][y - 1] = ELEMENT_TYPES.STEAM;
                return;
            }
            
            // éšæœºä¾§å‘æ‰©æ•£
            if (Math.random() < 0.2) {
                const dir = Math.random() > 0.5 ? 1 : -1;
                if (x + dir >= 0 && x + dir < config.gridWidth && grid[x + dir][y] === ELEMENT_TYPES.EMPTY) {
                    grid[x][y] = ELEMENT_TYPES.EMPTY;
                    grid[x + dir][y] = ELEMENT_TYPES.STEAM;
                    return;
                }
            }
            
            // é‡å†·å‡ç»“ï¼ˆè¾¹ç¼˜åŒºåŸŸï¼‰
            if (x === 0 || x === config.gridWidth - 1 || y === 0 || y === config.gridHeight - 1) {
                if (Math.random() < 0.02) {
                    grid[x][y] = ELEMENT_TYPES.WATER;
                }
            }
        }

        // ç»˜åˆ¶ç½‘æ ¼
        function drawGrid() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            for (let x = 0; x < config.gridWidth; x++) {
                for (let y = 0; y < config.gridHeight; y++) {
                    const element = grid[x][y];
                    if (element !== ELEMENT_TYPES.EMPTY) {
                        ctx.fillStyle = ELEMENT_COLORS[element];
                        ctx.fillRect(
                            x * config.particleSize, 
                            y * config.particleSize, 
                            config.particleSize, 
                            config.particleSize
                        );
                    }
                }
            }
        }

        // ä¸»åŠ¨ç”»å¾ªç¯
        function animate() {
            updatePhysics();
            drawGrid();
            requestAnimationFrame(animate);
        }

        // åˆå§‹åŒ–
        function init() {
            // è®¾ç½®é»˜è®¤æ¿€æ´»æŒ‰é’®
            document.querySelector('.element-button[data-element="sand"]').classList.add('active');
            
            // ç»˜åˆ¶åˆå§‹ç½‘æ ¼
            drawGrid();
            
            // å¼€å§‹åŠ¨ç”»
            animate();
        }

        // å¯åŠ¨æ¨¡æ‹Ÿ
        window.addEventListener('load', init);
    </script>
</body>
</html>
