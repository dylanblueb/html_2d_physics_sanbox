<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>ç‰©ç†æ²™ç›’ Â· è§†è§‰ç¼–ç»‡åœº</title>
  <style>
    /* --- è§†è§‰ä¸æ’ç‰ˆï¼ˆéµå¾ªç”¨æˆ·çš„ç¾å­¦æŒ‡å¼•ï¼‰ --- */
    :root{
      --bg:#f7f8fa;
      --panel:#ffffff;
      --muted:#7a8691;
      --ink:#1f2a37;
      --accent:#2563eb;
      --soft:#eef2ff;
      --canvas-bg:#0f1220;
      --glass: rgba(255,255,255,0.6);
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, "PingFang SC", "Hiragino Sans GB", "Microsoft Yahei", "Helvetica Neue", Arial;
      background:linear-gradient(180deg,var(--bg) 0%, #eef3ff 100%);
      color:var(--ink);
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
      padding:32px;
      display:flex;
      justify-content:center;
      align-items:flex-start;
    }

    .stage {
      width:1100px;
      max-width:calc(100% - 48px);
      display:grid;
      grid-template-columns: 320px 1fr;
      gap:24px;
      align-items:start;
    }

    header {
      grid-column: 1 / -1;
      text-align:left;
      margin-bottom:6px;
    }

    h1{
      font-size:28px;
      line-height:1;
      margin:0 0 6px 0;
      font-weight:700;
      letter-spacing: -0.02em;
    }
    p.lead{
      margin:0;
      color:var(--muted);
      font-size:13px;
    }

    /* å·¦ä¾§æ§åˆ¶æ ï¼ˆå‘¼å¸ä¸ºç•™ç™½ï¼‰ */
    .controls {
      background:var(--panel);
      border-radius:14px;
      padding:18px;
      box-shadow:0 8px 30px rgba(18,30,50,0.06);
      display:flex;
      flex-direction:column;
      gap:12px;
    }

    .controls h3{
      margin:0 0 6px 0;
      font-size:14px;
      color:var(--ink);
    }

    .palette{
      display:grid;
      grid-template-columns:repeat(2,1fr);
      gap:8px;
    }
    .btn{
      border:0;
      padding:10px 12px;
      border-radius:10px;
      cursor:pointer;
      display:flex;
      gap:8px;
      align-items:center;
      font-weight:600;
      font-size:13px;
      color:white;
      box-shadow: 0 2px 8px rgba(16,24,40,0.06);
      transition: transform .12s ease, box-shadow .12s ease;
    }
    .btn:active{transform:scale(.99)}
    .btn.small{font-size:12px;padding:8px;border-radius:8px}
    .btn.toggled{outline:3px solid rgba(37,99,235,0.12); transform:translateY(-2px)}

    .e-water{background:linear-gradient(180deg,#4aa3ff,#2b7ed9)}
    .e-sand{background:linear-gradient(180deg,#f6b35b,#e08b2b)}
    .e-stone{background:linear-gradient(180deg,#a7afb6,#7f868b)}
    .e-wood{background:linear-gradient(180deg,#8b5a2b,#a86b3b)}
    .e-fire{background:linear-gradient(180deg,#ff6b4a,#e0422a)}
    .e-steam{background:linear-gradient(180deg,#dfe7ee,#ffffff); color:#1f2a37}
    .e-ice{background:linear-gradient(180deg,#bfe7ff,#9fd6ff); color:#05314a}

    .controls .row{display:flex;gap:8px;flex-wrap:wrap}
    .label{font-size:12px;color:var(--muted);margin-bottom:6px}

    .sliders{
      background:var(--soft);
      padding:10px;border-radius:10px;
      display:flex;flex-direction:column;gap:8px;
    }

    /* ç”»å¸ƒé¢æ¿ï¼ˆä¸»å±å¹•å ä¸€é¢˜å½“ä»¤ï¼‰*/
    .canvas-panel{
      background:var(--panel);
      border-radius:14px;
      padding:14px;
      box-shadow:0 8px 30px rgba(18,30,50,0.06);
      display:flex;
      flex-direction:column;
      gap:12px;
    }

    .canvas-top{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:8px;
    }
    .controls-compact{display:flex;gap:8px;align-items:center}
    .kbd{background:#111827;color:white;padding:6px 8px;border-radius:8px;font-size:12px}

    .canvas-wrap{
      background:var(--canvas-bg);
      border-radius:10px;
      padding:12px;
      display:flex;
      justify-content:center;
      align-items:center;
      position:relative;
      box-shadow: inset 0 1px 0 rgba(255,255,255,0.02);
    }

    canvas#sim {
      image-rendering: pixelated;
      border-radius:6px;
      background:linear-gradient(180deg,#0b0d14 0%, #101220 100%);
      box-shadow: 0 10px 30px rgba(7,10,20,0.6);
      display:block;
      max-width:100%;
      height:auto;
    }

    .legend{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
      font-size:12px;color:var(--muted)
    }
    .legend .item{display:flex;gap:8px;align-items:center;background:rgba(255,255,255,0.02);padding:6px 8px;border-radius:8px}
    .swatch{width:14px;height:14px;border-radius:3px;box-shadow: inset 0 -1px 0 rgba(0,0,0,0.2)}

    /* è¯´æ˜é¢æ¿ */
    .notes{
      grid-column:1 / -1;
      background:linear-gradient(180deg, rgba(255,255,255,0.9), rgba(255,255,255,0.96));
      border-radius:12px;padding:14px;color:var(--muted);font-size:13px;
      box-shadow:0 6px 20px rgba(16,24,40,0.04)
    }

    footer{margin-top:18px;text-align:center;color:var(--muted);font-size:12px}
    @media (max-width:980px){
      .stage{grid-template-columns:1fr; gap:12px}
      .controls{order:2}
      .canvas-panel{order:1}
    }
  </style>
</head>
<body>
  <main class="stage" aria-labelledby="title">
    <header>
      <h1 id="title">ç‰©ç†æ²™ç›’ Â· è§†è§‰ç¼–ç»‡åœº</h1>
      <p class="lead">å…‰ä¸ç•™ç™½ï¼Œå¼ åŠ›ä¸æµâ€”â€”2Dç«–ç›´åˆ‡é¢ç‰©ç†æ²™ç›’ã€‚å…ƒç´ ï¼šæ°´ / æ²™ / çŸ³ / æœ¨ï¼ˆå«æ¤ç‰©ç‰¹æ€§ï¼‰ / ç« / è’¸æ±½ / å†° â€”â€” åŒ…å«é‡åŠ›ã€çƒ­ä¼ å¯¼ã€çŠ¶æ€å˜åŒ–ä¸åŸºæœ¬ç”Ÿæ€è§„å¾‹ã€‚</p>
    </header>

    <!-- å·¦ï¼šæ§åˆ¶ -->
    <aside class="controls" aria-label="æ§åˆ¶é¢æ¿">
      <div>
        <h3>é€‰æ‹©å…ƒç´ </h3>
        <div class="palette" role="list">
          <button class="btn e-water" data-el="water" role="listitem">ğŸ’§ æ°´</button>
          <button class="btn e-sand" data-el="sand" role="listitem">ğŸŒ¾ æ²™</button>
          <button class="btn e-stone" data-el="stone" role="listitem">ğŸª¨ çŸ³å¤´</button>
          <button class="btn e-wood" data-el="wood" role="listitem">ğŸªµ æœ¨æ</button>
          <button class="btn e-fire" data-el="fire" role="listitem">ğŸ”¥ ç«ç„°</button>
          <button class="btn e-steam" data-el="steam" role="listitem">â˜ï¸ è’¸æ±½</button>
          <button class="btn e-ice" data-el="ice" role="listitem">â„ï¸ å†°</button>
        </div>
      </div>

      <div>
        <h3>ç”»å¸ƒæ§åˆ¶</h3>
        <div class="row">
          <button id="eraseBtn" class="btn small" style="background:#6b7280">æ©¡çš®</button>
          <button id="clearBtn" class="btn small" style="background:#ef4444">æ¸…å±</button>
          <button id="pauseBtn" class="btn small" style="background:#2563eb">æš‚åœ</button>
        </div>
      </div>

      <div>
        <h3>å‚æ•°</h3>
        <div class="sliders">
          <div class="label">é‡åŠ›ï¼š<span id="gravityVal">0.6</span></div>
          <input id="gravity" type="range" min="0" max="1.2" step="0.05" value="0.6">
          <div class="label">ç²’å­å°ºå¯¸ï¼ˆåƒç´ ï¼‰ï¼š<span id="psizeVal">4</span></div>
          <input id="psize" type="range" min="2" max="8" step="1" value="4">
          <div class="label">ç¯å¢ƒæ¸©åº¦ï¼ˆåˆå§‹ï¼‰ï¼š<span id="ambientVal">20</span> Â°C</div>
          <input id="ambient" type="range" min="-20" max="120" step="1" value="20">
        </div>
      </div>

      <div>
        <h3>æç¤º</h3>
        <div style="color:var(--muted);font-size:13px;line-height:1.45">
          - å·¦é”®ç»˜åˆ¶æ‰€é€‰å…ƒç´ ï¼›å³é”®å–æ ·ï¼ˆæŒ‰ä½ Shift åˆ‡æ¢æ©¡çš®ï¼‰ã€‚<br>
          - æ–°å…ƒç´ ä¸ä¼šè¦†ç›–å·²æœ‰å…ƒç´ ï¼Œä¼šè‡ªåŠ¨åœ¨æœ€è¿‘ç©ºç™½å¤„ç”Ÿæˆã€‚<br>
          - æ‰€æœ‰å…ƒç´ éƒ½ä¼šå—é‡åŠ›å½±å“è½ä¸‹ï¼ŒåŒ…æ‹¬çŸ³å¤´å’Œæœ¨æã€‚<br>
          - æœ¨æèåˆäº†æ¤ç‰©ç‰¹æ€§ï¼Œéœ€è¦æ°´åˆ†ç»´æŒï¼Œä¼šæ¶ˆè€—é‚»è¿‘æ°´æºï¼›ç¼ºæ°´æ—¶æ­»äº¡ã€‚ç«ç„°å¯ç‚¹ç‡ƒæœ¨æã€‚<br>
          - å†°ä¼šéšæ¸©åº¦è½¬ä¸ºæ°´æˆ–è’¸æ±½ï¼›é€‚å½“é™ä½ç²’å­å°ºå¯¸å¯è·å¾—æ›´ç»†è…»çš„æµä½“è¡¨ç°ã€‚
        </div>
      </div>
    </aside>

    <!-- å³ï¼šç”»å¸ƒ -->
    <section class="canvas-panel" aria-label="æ¨¡æ‹Ÿç”»å¸ƒ">
      <div class="canvas-top">
        <div>
          <strong>æ¨¡æ‹Ÿç”»å¸ƒ</strong>
          <div style="font-size:12px;color:var(--muted)">ç«–ç›´åˆ‡é¢ Â· 2D ç²’å­æ ¼</div>
        </div>
        <div class="controls-compact">
          <div class="kbd" id="modeDisplay">æ¨¡å¼ï¼šç»˜åˆ¶</div>
          <div style="width:12px"></div>
          <div class="legend" aria-hidden="true">
            <div class="item"><div class="swatch" style="background:#4aa3ff"></div>æ°´</div>
            <div class="item"><div class="swatch" style="background:#f6b35b"></div>æ²™</div>
            <div class="item"><div class="swatch" style="background:#a7afb6"></div>çŸ³</div>
            <div class="item"><div class="swatch" style="background:#8b5a2b"></div>æœ¨</div>
            <div class="item"><div class="swatch" style="background:#ff6b4a"></div>ç«</div>
            <div class="item"><div class="swatch" style="background:#dfe7ee"></div>è’¸æ±½</div>
            <div class="item"><div class="swatch" style="background:#bfe7ff"></div>å†°</div>
          </div>
        </div>
      </div>

      <div class="canvas-wrap" id="canvasWrap">
        <canvas id="sim" width="800" height="600" aria-label="ç‰©ç†æ²™ç›’ç”»å¸ƒ"></canvas>
      </div>
    </section>

    <section class="notes" aria-label="è¯´æ˜">
      <strong>ç‰©ç†è§„åˆ™ï¼ˆæ‘˜è¦ï¼‰</strong>
      <ul>
        <li>é‡åŠ›ï¼šæ‰€æœ‰å…ƒç´ éƒ½ä¼šå—é‡åŠ›å½±å“è½ä¸‹ï¼ŒåŒ…æ‹¬çŸ³å¤´å’Œæœ¨æã€‚</li>
        <li>çƒ­åŠ›ï¼šç«ç„°æé«˜å‘¨å›´æ¸©åº¦ï¼›æ¸©åº¦é©±åŠ¨ç›¸å˜ï¼šå†°â†’æ°´â†’è’¸æ±½ï¼›è’¸æ±½é‡å†·å‡ç»“ä¸ºæ°´ã€‚</li>
        <li>æœ¨æç‰¹æ€§ï¼šèåˆäº†æ¤ç‰©ç‰¹æ€§ï¼Œéœ€è¦æ°´åˆ†ç»´æŒç”Ÿå‘½ï¼Œä¼šæ¶ˆè€—é‚»è¿‘æ°´æºï¼›ç¼ºæ°´æ—¶æ­»äº¡ã€‚ç«ç„°å¯ç‚¹ç‡ƒæœ¨æã€‚</li>
        <li>å…ƒç´ æ”¾ç½®ï¼šæ–°å…ƒç´ ä¸ä¼šè¦†ç›–å·²æœ‰å…ƒç´ ï¼Œä¼šè‡ªåŠ¨åœ¨æœ€è¿‘çš„ç©ºç™½å¤„ç”Ÿæˆã€‚</li>
        <li>è¾¹ç•Œï¼šç”»å¸ƒå››å‘¨ä¸ºå®ç‰©è¾¹ç•Œï¼ˆæœ€ä¸‹æ–¹ä¸å¯ç©¿è¶Šï¼Œå…ƒç´ ä¸èƒ½æ‰å‡ºç”»å¸ƒï¼‰ã€‚</li>
      </ul>
    </section>

    <footer>è®¾è®¡ Â· è§†è§‰ç¼–ç»‡åœº â€” ä»¥ç•™ç™½ä¸ºæ°§ï¼Œé‡è¦åˆ™å¤§ï¼ŒæµåŠ¨æœ‰èŠ‚</footer>
  </main>

  <script>
    /* ================= ä¼˜åŒ–è¯´æ˜ï¼ˆé‡ç‚¹ï¼‰ =================
     - ä½¿ç”¨æ‰å¹³åŒ–æ …æ ¼ä¸ TypedArrayï¼ˆæ€§èƒ½æå‡ã€å‡å°‘ GCï¼‰
     - å°†æ¸©åº¦ç¼“å†²åŒºå¤ç”¨ï¼Œé¿å…æ¯å¸§åˆ†é…å¤§æ•°ç»„
     - BFSï¼ˆæœ€è¿‘ç©ºç™½ï¼‰æ”¹ä¸ºé˜Ÿåˆ—ç´¢å¼•å®ç°ï¼Œé¿å… shift() å¼€é”€å’Œå¤§é‡å­—ç¬¦ä¸² visited
     - åœ¨ç»˜åˆ¶ä¸æ›´æ–°å¾ªç¯ä¸­ç¼“å­˜å¸¸é‡ï¼ˆå‡å°‘å±æ€§æŸ¥æ‰¾ï¼‰
     - ä¿æŒè¡Œä¸ºä¸åŸç‰ˆæ¥è¿‘ï¼Œä½†æ˜¾è‘—é™ä½æ¯å¸§å¼€é”€
    =================================================== */

    const canvas = document.getElementById('sim');
    const ctx = canvas.getContext('2d');

    // åŠ¨æ€å‚æ•°ï¼ˆUI æ›´æ–°ï¼‰
    let PARAM = {
      particleSize: 4,
      gravity: 0.6,
      ambientTemp: 20,
      fpsLimit: 60
    };

    // å…ƒç´ ç±»å‹ï¼ˆä½¿ç”¨å°æ•´æ•°ï¼‰
    const EL = {
      EMPTY: 0, SAND: 1, WATER: 2, STONE: 3, WOOD: 4,
      FIRE: 5, STEAM: 6, ICE: 7
    };

    const COLORS = {
      [EL.EMPTY]: '#0f1220',
      [EL.SAND]: '#f6b35b',
      [EL.WATER]: '#4aa3ff',
      [EL.STONE]: '#a7afb6',
      [EL.WOOD]: '#8b5a2b',
      [EL.FIRE]: '#ff6b4a',
      [EL.STEAM]: '#dfe7ee',
      [EL.ICE]: '#bfe7ff'
    };

    // ç½‘æ ¼å°ºå¯¸ï¼ˆcols, rowsï¼‰ä¸æ‰å¹³åŒ–æ•°ç»„ï¼ˆindex = x + y*COLSï¼‰
    let COLS = 0, ROWS = 0;
    let SIZE = 0; // COLS * ROWS

    // Typed arraysï¼ˆå¤ç”¨ï¼‰
    let grid;                // Uint8Array
    let temp;                // Float32Array
    let fireLife;            // Float32Array
    let woodHydration;       // Float32Array
    let woodWaterConsumed;   // Float32Array

    // ä¸´æ—¶ç”¨äº diffusion çš„ç¼“å†²åŒºï¼ˆå¤ç”¨ï¼‰
    let newTemp;

    // å¸®åŠ©ï¼šç´¢å¼• / è¾¹ç•Œ
    const idx = (x,y) => x + y * COLS;
    const clampInt = (v, a, b) => Math.max(a, Math.min(b, Math.floor(v)));

    function allocGrid(){
      // è®¡ç®— COLS/ROWS åŸºäº canvas çš„ç»˜åˆ¶åƒç´ å¤§å°ä¸ç²’å­å°ºå¯¸
      COLS = Math.max(8, Math.floor(canvas.width / PARAM.particleSize));
      ROWS = Math.max(8, Math.floor(canvas.height / PARAM.particleSize));
      SIZE = COLS * ROWS;

      grid = new Uint8Array(SIZE);                 // é»˜è®¤ 0 (EMPTY)
      temp = new Float32Array(SIZE);
      fireLife = new Float32Array(SIZE);
      woodHydration = new Float32Array(SIZE);
      woodWaterConsumed = new Float32Array(SIZE);
      newTemp = new Float32Array(SIZE);

      // åˆå§‹åŒ–æ¸©åº¦ä¸ºç¯å¢ƒæ¸©åº¦
      for (let i = 0; i < SIZE; i++) temp[i] = PARAM.ambientTemp;
    }

    // åˆå§‹åŒ–
    // æ³¨æ„ï¼šåˆå§‹ canvas å®½é«˜æ¥è‡ªå±æ€§ï¼Œresize ä¼šé‡æ–°é…ç½® dpr ä¸æ …æ ¼
    allocGrid();

    /* ========= UI ç»‘å®šï¼ˆä¿æŒåŸæ ·ï¼‰ ========= */
    const buttons = document.querySelectorAll('.palette .btn');
    let current = EL.SAND;
    const mapStrToEl = {sand:EL.SAND, water:EL.WATER, stone:EL.STONE, wood:EL.WOOD, fire:EL.FIRE, steam:EL.STEAM, ice:EL.ICE};
    const mapElToStr = Object.fromEntries(Object.entries(mapStrToEl).map(([k,v])=>[v,k]));

    buttons.forEach(b=>{
      b.addEventListener('click', ()=>{
        buttons.forEach(x=>x.classList.remove('toggled'));
        b.classList.add('toggled');
        const key = b.dataset.el;
        current = mapStrToEl[key] ?? EL.SAND;
      });
    });
    document.querySelector('.btn[data-el="sand"]').classList.add('toggled');

    const eraseBtn = document.getElementById('eraseBtn');
    const clearBtn = document.getElementById('clearBtn');
    const pauseBtn = document.getElementById('pauseBtn');
    const modeDisplay = document.getElementById('modeDisplay');

    let eraseMode = false;
    let paused = false;
    eraseBtn.addEventListener('click', ()=>{ eraseMode = !eraseMode; modeDisplay.textContent = eraseMode ? 'æ¨¡å¼ï¼šæ©¡çš®' : 'æ¨¡å¼ï¼šç»˜åˆ¶'; eraseBtn.style.opacity = eraseMode ? '1' : '0.7' });
    clearBtn.addEventListener('click', ()=>{ allocGrid(); draw(); });
    pauseBtn.addEventListener('click', ()=>{ paused = !paused; pauseBtn.textContent = paused ? 'ç»§ç»­' : 'æš‚åœ'; });

    const gravitySlider = document.getElementById('gravity');
    const psizeSlider = document.getElementById('psize');
    const ambientSlider = document.getElementById('ambient');
    const gravityVal = document.getElementById('gravityVal');
    const psizeVal = document.getElementById('psizeVal');
    const ambientVal = document.getElementById('ambientVal');

    gravitySlider.value = PARAM.gravity; gravityVal.textContent = PARAM.gravity;
    psizeSlider.value = PARAM.particleSize; psizeVal.textContent = PARAM.particleSize;
    ambientSlider.value = PARAM.ambientTemp; ambientVal.textContent = PARAM.ambientTemp;

    gravitySlider.addEventListener('input', e=>{ PARAM.gravity = parseFloat(e.target.value); gravityVal.textContent = PARAM.gravity; });
    ambientSlider.addEventListener('input', e=>{ PARAM.ambientTemp = parseFloat(e.target.value); ambientVal.textContent = PARAM.ambientTemp; });
    psizeSlider.addEventListener('input', e=>{
      PARAM.particleSize = parseInt(e.target.value);
      psizeVal.textContent = PARAM.particleSize;
      allocGrid();
      draw();
    });

    /* ========= é¼ æ ‡ç»˜åˆ¶ï¼ˆä¿ç•™åŸäº¤äº’ä½†æ›´é«˜æ•ˆï¼‰ ========= */
    let drawing = false;
    let last = null;

    function toCell(clientX, clientY){
      const rect = canvas.getBoundingClientRect();
      const cx = clientX - rect.left;
      const cy = clientY - rect.top;
      const col = clampInt(cx / PARAM.particleSize, 0, COLS - 1);
      const row = clampInt(cy / PARAM.particleSize, 0, ROWS - 1);
      return {col, row};
    }

    canvas.addEventListener('pointerdown', e=>{
      drawing = true;
      canvas.setPointerCapture?.(e.pointerId);
      if (e.button === 2) {
        const {col,row} = toCell(e.clientX, e.clientY);
        const value = grid[idx(col,row)];
        if (value !== undefined) {
          current = value || current;
          const key = mapElToStr[current];
          if (key){
            buttons.forEach(x=>x.classList.remove('toggled'));
            const btn = document.querySelector(`.btn[data-el="${key}"]`);
            if (btn) btn.classList.add('toggled');
          }
        }
      } else {
        handlePaint(e);
      }
    });
    canvas.addEventListener('pointermove', e=>{ if (drawing) handlePaint(e); });
    canvas.addEventListener('pointerup', e=>{ drawing = false; canvas.releasePointerCapture?.(e.pointerId); last = null; });
    canvas.addEventListener('contextmenu', e=> e.preventDefault());

    function handlePaint(e){
      const {col,row} = toCell(e.clientX, e.clientY);
      if (eraseMode || e.shiftKey) {
        paintBlock(col,row,EL.EMPTY);
      } else {
        paintBlock(col,row,current);
      }
      if (last){
        linePaint(last.col,last.row,col,row,current,(eraseMode|| e.shiftKey));
      }
      last = {col,row};
    }

    /* ========= å¯»æ‰¾æœ€è¿‘ç©ºç™½ï¼ˆBFS ä¼˜åŒ–ï¼šé˜Ÿåˆ—ç´¢å¼• + è®¿é—®ä½å›¾ï¼‰ ========= */
    function findNearestEmpty(sx, sy){
      const startI = idx(sx, sy);
      if (grid[startI] === EL.EMPTY) return {x: sx, y: sy};

      // é¢„åˆ†é…é˜Ÿåˆ—ï¼ˆåŠ¨æ€æ‰©å±•ï¼‰ï¼Œä½¿ç”¨ä¸¤ä¸ªæ•°ç»„ä¿å­˜ x,y æˆ– index å½¢å¼
      const qx = new Int16Array(SIZE); // å¯èƒ½æµªè´¹ï¼Œä½†é¿å… push/shift
      const qy = new Int16Array(SIZE);
      let head = 0, tail = 0;

      const visited = new Uint8Array(SIZE);
      qx[tail] = sx; qy[tail] = sy; tail++;
      visited[startI] = 1;

      // ä¼˜å…ˆæ–¹å‘ï¼šä¸‹/å·¦å³/ä¸Š
      const dirs = [[0,1],[1,0],[-1,0],[0,-1],[1,1],[-1,1],[1,-1],[-1,-1]];

      while (head < tail){
        const x = qx[head], y = qy[head]; head++;
        for (let i=0;i<dirs.length;i++){
          const nx = x + dirs[i][0];
          const ny = y + dirs[i][1];
          if (nx < 0 || nx >= COLS || ny < 0 || ny >= ROWS) continue;
          const ni = idx(nx, ny);
          if (visited[ni]) continue;
          if (grid[ni] === EL.EMPTY) return {x: nx, y: ny};
          visited[ni] = 1;
          qx[tail] = nx; qy[tail] = ny; tail++;
        }
      }
      return {x: sx, y: sy};
    }

    function paintBlock(cx, cy, el){
      const radius = Math.max(0, Math.floor(PARAM.particleSize / 2));
      for (let dx = -radius; dx <= radius; dx++){
        for (let dy = -radius; dy <= radius; dy++){
          const x = cx + dx, y = cy + dy;
          if (x < 0 || x >= COLS || y < 0 || y >= ROWS) continue;
          const i = idx(x,y);
          if (el === EL.EMPTY){
            grid[i] = EL.EMPTY;
            fireLife[i] = 0;
            woodHydration[i] = 0;
            woodWaterConsumed[i] = 0;
            continue;
          }
          if (grid[i] === EL.EMPTY){
            // ç›´æ¥æ”¾ç½®
            grid[i] = el;
            if (el === EL.FIRE) fireLife[i] = 120;
            if (el === EL.WOOD) { woodHydration[i] = 60; woodWaterConsumed[i] = 0; }
            if (el === EL.ICE) temp[i] = Math.min(temp[i], 0);
            if (el === EL.WATER) temp[i] = Math.max(temp[i], PARAM.ambientTemp);
          } else {
            // æ‰¾æœ€è¿‘ç©ºç™½ï¼ˆå°èŒƒå›´ BFSï¼‰
            const p = findNearestEmpty(x,y);
            const ni = idx(p.x, p.y);
            if (grid[ni] === EL.EMPTY){
              grid[ni] = el;
              if (el === EL.FIRE) fireLife[ni] = 120;
              if (el === EL.WOOD) { woodHydration[ni] = 60; woodWaterConsumed[ni] = 0; }
              if (el === EL.ICE) temp[ni] = Math.min(temp[ni], 0);
              if (el === EL.WATER) temp[ni] = Math.max(temp[ni], PARAM.ambientTemp);
            }
          }
        }
      }
    }

    function linePaint(x0,y0,x1,y1,el,isErase=false){
      const dx = Math.abs(x1-x0), dy = Math.abs(y1-y0);
      const sx = x0 < x1 ? 1 : -1, sy = y0 < y1 ? 1 : -1;
      let err = dx - dy;
      let x = x0, y = y0;
      while (true){
        paintBlock(x,y, isErase ? EL.EMPTY : el);
        if (x === x1 && y === y1) break;
        const e2 = 2 * err;
        if (e2 > -dy) { err -= dy; x += sx; }
        if (e2 < dx) { err += dx; y += sy; }
      }
    }

    /* ========= ç‰©ç†è§„åˆ™ï¼ˆæ‰å¹³åŒ–å®ç°ï¼‰ ========= */
    const MELT_TEMP = 2;     // å†°â†’æ°´
    const BOIL_TEMP = 90;    // æ°´â†’è’¸æ±½
    const CONDENSE_TEMP = 50;// è’¸æ±½â†’æ°´

    function swap(i1, i2){
      // swap grid
      const t = grid[i1]; grid[i1] = grid[i2]; grid[i2] = t;
      // swap temp & other state arrays
      const tt = temp[i1]; temp[i1] = temp[i2]; temp[i2] = tt;
      const f = fireLife[i1]; fireLife[i1] = fireLife[i2]; fireLife[i2] = f;
      const wh = woodHydration[i1]; woodHydration[i1] = woodHydration[i2]; woodHydration[i2] = wh;
      const wc = woodWaterConsumed[i1]; woodWaterConsumed[i1] = woodWaterConsumed[i2]; woodWaterConsumed[i2] = wc;
    }

    function inBounds(x,y){ return x >= 0 && x < COLS && y >= 0 && y < ROWS; }

    // å•å¸§æ›´æ–°ï¼ˆé«˜é¢‘ï¼‰
    function step(){
      // 1) æ¸©åº¦æ‰©æ•£ï¼ˆä½¿ç”¨ newTemp å¤ç”¨ç¼“å†²ï¼‰
      const ambient = PARAM.ambientTemp;
      // ä¸ºæ€§èƒ½ï¼Œå°†å¸¸é‡ç¼“å­˜
      for (let i = 0; i < SIZE; i++) newTemp[i] = temp[i] * 0.6;

      // æ¨èé‚»å±…æƒé‡ï¼šorthogonal 0.1 each
      for (let y = 0; y < ROWS; y++){
        const base = y * COLS;
        for (let x = 0; x < COLS; x++){
          let t = temp[base + x] * 0.6;
          let count = 0.6;
          // neighbors
          if (x+1 < COLS){ t += temp[base + x + 1] * 0.1; count += 0.1; }
          if (x-1 >= 0){ t += temp[base + x - 1] * 0.1; count += 0.1; }
          if (y+1 < ROWS){ t += temp[base + COLS + x] * 0.1; count += 0.1; }
          if (y-1 >= 0){ t += temp[base - COLS + x] * 0.1; count += 0.1; }
          t = t / count;
          t += (ambient - t) * 0.004;
          newTemp[base + x] = t;
        }
      }
      // swap buffers (copy back)
      for (let i = 0; i < SIZE; i++) temp[i] = newTemp[i];

      // 2) å…ƒç´ æ›´æ–°ï¼šä»ä¸‹åˆ°ä¸Šï¼ˆé¿å…è¦†ç›–å¯¼è‡´é‡å¤ç§»åŠ¨ï¼‰
      // ç¼“å­˜ä¸€äº›å¸¸é‡
      const gs = PARAM.gravity;
      for (let y = ROWS - 2; y >= 0; y--){
        const base = y * COLS;
        const belowBase = (y + 1) * COLS;
        for (let x = 0; x < COLS; x++){
          const i = base + x;
          const el = grid[i];
          if (el === EL.EMPTY) continue;
          switch (el){
            case EL.SAND:
              updateSand(i, x, y, belowBase); break;
            case EL.WATER:
              updateWater(i, x, y, belowBase); break;
            case EL.ICE:
              updateIce(i, x, y, belowBase); break;
            case EL.FIRE:
              updateFire(i, x, y, base); break;
            case EL.STEAM:
              updateSteam(i, x, y); break;
            case EL.STONE:
              updateStone(i, x, y, belowBase); break;
            case EL.WOOD:
              updateWood(i, x, y, belowBase); break;
            default:
              break;
          }
        }
      }

      // bottom row fire handling
      const bottomY = ROWS - 1;
      const baseBot = bottomY * COLS;
      for (let x = 0; x < COLS; x++){
        const i = baseBot + x;
        if (grid[i] === EL.FIRE){
          fireLife[i] -= 4;
          if (fireLife[i] <= 0) { grid[i] = EL.EMPTY; fireLife[i] = 0; }
        }
      }
    }

    /* ---------- å„å…ƒç´ è¡Œä¸ºï¼ˆåŸºäºç´¢å¼•ï¼‰ ---------- */

    function updateSand(i, x, y, belowBase){
      const belowI = belowBase + x;
      if (y + 1 < ROWS){
        const below = grid[belowI];
        if (below === EL.EMPTY || below === EL.STEAM || below === EL.WATER){
          swap(i, belowI); return;
        }
        // diagonal
        const dirs = Math.random() > 0.5 ? [1,-1] : [-1,1];
        for (let k=0;k<2;k++){
          const nx = x + dirs[k];
          if (nx>=0 && nx<COLS){
            const ni = belowBase + nx;
            const g = grid[ni];
            if (g === EL.EMPTY || g === EL.STEAM){ swap(i, ni); return; }
          }
        }
      }
    }

    function updateWater(i, x, y, belowBase){
      if (y + 1 < ROWS){
        const belowI = belowBase + x;
        const below = grid[belowI];
        if (below === EL.EMPTY || below === EL.STEAM){ swap(i, belowI); return; }
        const dir = Math.random() > 0.5 ? 1 : -1;
        if (x + dir >= 0 && x + dir < COLS){
          const ni = belowBase + (x + dir);
          const g = grid[ni];
          if (g === EL.EMPTY || g === EL.STEAM){ swap(i, ni); return; }
        }
        if (x - dir >= 0 && x - dir < COLS){
          const ni = belowBase + (x - dir);
          const g = grid[ni];
          if (g === EL.EMPTY || g === EL.STEAM){ swap(i, ni); return; }
        }
      }
      // horizontal spread
      if (Math.random() > 0.4){
        if (x + 1 < COLS && grid[i + 1] === EL.EMPTY){ swap(i, i + 1); return; }
      } else {
        if (x - 1 >= 0 && grid[i - 1] === EL.EMPTY){ swap(i, i - 1); return; }
      }
      // boil -> steam
      if (temp[i] >= BOIL_TEMP && Math.random() < 0.12){
        grid[i] = EL.STEAM;
        temp[i] += 8;
      }
    }

    function updateIce(i, x, y, belowBase){
      if (temp[i] >= MELT_TEMP){
        grid[i] = EL.WATER; return;
      }
      if (y + 1 < ROWS){
        const belowI = belowBase + x;
        const below = grid[belowI];
        if (below === EL.EMPTY || below === EL.STEAM || below === EL.WATER){ swap(i, belowI); return; }
        const dirs = Math.random() > 0.5 ? [1,-1] : [-1,1];
        for (let k=0;k<2;k++){
          const nx = x + dirs[k];
          if (nx>=0 && nx<COLS){
            const ni = belowBase + nx;
            const g = grid[ni];
            if (g === EL.EMPTY || g === EL.STEAM){ swap(i, ni); return; }
          }
        }
      }
    }

    function updateSteam(i, x, y){
      if (y - 1 >= 0){
        const upI = i - COLS;
        if (grid[upI] === EL.EMPTY){ swap(i, upI); return; }
      }
      if (Math.random() < 0.25){
        const dir = Math.random() > 0.5 ? 1 : -1;
        const nx = x + dir;
        if (nx >= 0 && nx < COLS && grid[i + dir] === EL.EMPTY){ swap(i, i + dir); return; }
      }
      if (temp[i] <= CONDENSE_TEMP && Math.random() < 0.05){
        grid[i] = EL.WATER; return;
      }
    }

    function updateFire(i, x, y, base){
      fireLife[i] -= 2;
      temp[i] += 12;
      // spread heat to neighbors
      const neighbors = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[-1,1],[1,-1],[-1,-1]];
      for (let n=0;n<neighbors.length;n++){
        const nx = x + neighbors[n][0], ny = y + neighbors[n][1];
        if (!inBounds(nx, ny)) continue;
        temp[idx(nx, ny)] += 6;
      }
      const topFactor = (y < ROWS * 0.15) ? 0.15 : 0.03;
      if (fireLife[i] <= 0 || Math.random() < topFactor){
        grid[i] = EL.EMPTY; fireLife[i] = 0; return;
      }
      // flame rises
      if (y - 1 >= 0){
        const upI = i - COLS;
        if (grid[upI] === EL.EMPTY){
          grid[upI] = EL.FIRE;
          fireLife[upI] = Math.max(20, fireLife[i] - 8);
          grid[i] = EL.EMPTY; fireLife[i] = 0; return;
        }
      }
      // horizontal / random spread
      let sideChance = (y < ROWS * 0.15) ? 0.08 : 0.28;
      if (Math.random() < sideChance){
        const dir = Math.random() > 0.5 ? 1 : -1;
        const nx = x + dir;
        if (nx >= 0 && nx < COLS && grid[i + dir] === EL.EMPTY){
          grid[i + dir] = EL.FIRE;
          fireLife[i + dir] = Math.max(20, fireLife[i] - 10);
          grid[i] = EL.EMPTY; fireLife[i] = 0; return;
        }
      }
      // interactions
      for (let n=0;n<neighbors.length;n++){
        const nx = x + neighbors[n][0], ny = y + neighbors[n][1];
        if (!inBounds(nx, ny)) continue;
        const ni = idx(nx, ny);
        const nearby = grid[ni];
        if (nearby === EL.WATER && Math.random() < 0.18){
          grid[ni] = EL.STEAM; temp[ni] += 18;
        } else if (nearby === EL.WOOD && Math.random() < 0.25){
          grid[ni] = EL.FIRE; fireLife[ni] = 140;
        } else if (nearby === EL.STONE){
          temp[ni] += 6;
        } else {
          if (nearby === EL.EMPTY && Math.random() < 0.02){
            grid[ni] = EL.FIRE; fireLife[ni] = 50;
          }
        }
      }
    }

    function updateStone(i, x, y, belowBase){
      if (y + 1 < ROWS){
        const belowI = belowBase + x;
        const below = grid[belowI];
        if (below === EL.EMPTY || below === EL.STEAM || below === EL.WATER){
          swap(i, belowI); return;
        }
        const dirs = Math.random() > 0.5 ? [1,-1] : [-1,1];
        for (let k=0;k<2;k++){
          const nx = x + dirs[k];
          if (nx>=0 && nx<COLS){
            const ni = belowBase + nx;
            const g = grid[ni];
            if (g === EL.EMPTY || g === EL.STEAM || g === EL.WATER){ swap(i, ni); return; }
          }
        }
      }
    }

    function updateWood(i, x, y, belowBase){
      // consumption rateï¼ˆå¯è°ƒï¼‰
      const waterConsumed = 0.002;
      woodHydration[i] -= waterConsumed;
      // å¸æ°´å°è¯•
      const neighbors = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[-1,1],[1,-1],[-1,-1]];
      for (let n=0;n<neighbors.length;n++){
        const nx = x + neighbors[n][0], ny = y + neighbors[n][1];
        if (!inBounds(nx, ny)) continue;
        const ni = idx(nx, ny);
        if (grid[ni] === EL.WATER && Math.random() < 0.05){
          grid[ni] = EL.EMPTY;
          woodHydration[i] += 8;
          temp[ni] -= 2;
          break;
        }
      }
      woodWaterConsumed[i] += waterConsumed;
      // å½“ç´¯ç§¯æ¶ˆè€—è¾¾åˆ° 1ï¼Œç”Ÿé•¿æœ€å¤š 2 ä¸ªæ–°æœ¨æ
      if (woodWaterConsumed[i] >= 1){
        // æ”¶é›†å¯èƒ½ç”Ÿé•¿ä½ç½®
        const possible = [];
        for (let n=0;n<neighbors.length;n++){
          const nx = x + neighbors[n][0], ny = y + neighbors[n][1];
          if (!inBounds(nx, ny)) continue;
          const ni = idx(nx, ny);
          if (grid[ni] === EL.EMPTY) possible.push(ni);
        }
        // éšæœºå–æœ€å¤š2ä¸ª
        if (possible.length > 0){
          for (let k = 0; k < Math.min(2, possible.length); k++){
            const pick = possible.splice(Math.floor(Math.random() * possible.length), 1)[0];
            grid[pick] = EL.WOOD;
            woodHydration[pick] = Math.max(0, woodHydration[i] * 0.8);
            woodWaterConsumed[pick] = 0;
          }
        }
        woodWaterConsumed[i] = 0;
      }
      if (woodHydration[i] <= 0){
        grid[i] = EL.EMPTY;
        woodHydration[i] = 0;
        woodWaterConsumed[i] = 0;
        return;
      }
      // ä¸‹è½é€»è¾‘ï¼ˆç±»ä¼¼çŸ³å¤´/æ²™ï¼‰
      if (y + 1 < ROWS){
        const belowI = belowBase + x;
        const below = grid[belowI];
        if (below === EL.EMPTY || below === EL.STEAM || below === EL.WATER){ swap(i, belowI); return; }
        const dirs = Math.random() > 0.5 ? [1,-1] : [-1,1];
        for (let k=0;k<2;k++){
          const nx = x + dirs[k];
          if (nx>=0 && nx<COLS){
            const ni = belowBase + nx;
            const g = grid[ni];
            if (g === EL.EMPTY || g === EL.STEAM || g === EL.WATER){ swap(i, ni); return; }
          }
        }
      }
      // é‚»è¿‘ç«ç‚¹ç‡ƒ
      for (let n=0;n<4;n++){
        const nx = x + neighbors[n][0], ny = y + neighbors[n][1];
        if (!inBounds(nx, ny)) continue;
        const ni = idx(nx, ny);
        if (grid[ni] === EL.FIRE && Math.random() < 0.35){
          grid[i] = EL.FIRE; fireLife[i] = 100; return;
        }
      }
    }

    /* ========= ç»˜åˆ¶ï¼ˆä½¿ç”¨æ‰å¹³ç´¢å¼• + è¡Œé¦–ç¼“å­˜ï¼‰ ========= */
    function draw(){
      ctx.clearRect(0,0,canvas.width,canvas.height);
      const ps = PARAM.particleSize;
      ctx.fillStyle = '#0b0d14';
      ctx.fillRect(0,0,canvas.width,canvas.height);

      // ä¸ºäº†å¿«é€Ÿè®¡ç®—åæ ‡ï¼Œé€šè¿‡è¡Œå¾ªç¯å¹¶ç¼“å­˜ baseIndex
      for (let y = 0; y < ROWS; y++){
        const base = y * COLS;
        for (let x = 0; x < COLS; x++){
          const i = base + x;
          const el = grid[i];
          if (el === EL.EMPTY) continue;

          let col = COLORS[el] ?? '#ffffff';
          if (el === EL.FIRE){
            const life = Math.max(0, Math.min(fireLife[i], 160));
            const t = life / 160;
            const r = Math.floor(255 * (0.6 + 0.4 * t));
            const g = Math.floor(80 * (0.4 + 0.6 * t));
            const b = Math.floor(30 * (0.1 + 0.1 * t));
            col = `rgb(${r},${g},${b})`;
          } else if (el === EL.ICE){
            const tt = Math.max(0, Math.min((temp[i] + 20) / 120, 1));
            const mix = Math.floor(200 + 55 * (1 - tt));
            col = `rgb(${mix}, ${230}, ${255})`;
          } else if (el === EL.WATER){
            const tt = Math.max(-1, Math.min((temp[i] - PARAM.ambientTemp) / 60, 1));
            if (tt > 0.6) col = '#a7e0ff';
            else if (tt < -0.5) col = '#2a8bd6';
            else col = COLORS[el];
          } else if (el === EL.WOOD){
            const h = Math.max(0, Math.min(woodHydration[i] / 80, 1));
            const r = Math.floor(139 * (0.7 + 0.3 * (1 - h)));
            const g = Math.floor(90 * h + 50 * (1 - h));
            const b = Math.floor(43 * (0.5 + 0.5 * h));
            col = `rgb(${r},${g},${b})`;
          } else {
            col = COLORS[el];
          }

          ctx.fillStyle = col;
          ctx.fillRect(x * ps, y * ps, ps, ps);
        }
      }
    }

    /* ========= ä¸»å¾ªç¯ ========= */
    let lastTime = performance.now();
    function tick(time){
      if (!paused){
        if (time - lastTime > (1000 / PARAM.fpsLimit)){
          step();
          draw();
          lastTime = time;
        }
      }
      requestAnimationFrame(tick);
    }
    requestAnimationFrame(tick);

    /* ========= åˆå§‹åŒ–ç§å­ï¼ˆç¤ºèŒƒç”¨ï¼‰ ========= */
    (function seed(){
      const base = ROWS - 1;
      for (let x=0;x<COLS;x+=2){
        if (Math.random() < 0.6){
          grid[base + x] = EL.STONE;
          temp[base + x] = PARAM.ambientTemp;
        }
      }
    })();

    /* ========= å¤„ç†é«˜ DPI ä¸å¤§å°å˜åŒ–ï¼ˆæ›´ç¨³å¥ï¼‰ ========= */
    function resizeCanvas(){
      // å°† canvas åœ¨è§†è§‰ä¸Šæ‹‰ä¼¸åˆ°å®¹å™¨çš„å¤§å°ï¼Œä½†ä½¿ç”¨ DPR æ¥æå‡ç»†èŠ‚
      const dpr = window.devicePixelRatio || 1;
      const rect = canvas.getBoundingClientRect();
      // å¦‚æœ rect.width/height ä¸º 0ï¼Œå°è¯•ä½¿ç”¨å±æ€§æˆ–é»˜è®¤
      const cw = Math.max(200, rect.width || canvas.width || 800);
      const ch = Math.max(200, rect.height || canvas.height || 600);
      canvas.width = Math.floor(cw * dpr);
      canvas.height = Math.floor(ch * dpr);
      canvas.style.width = cw + 'px';
      canvas.style.height = ch + 'px';
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      allocGrid();
      draw();
    }

    function fitCanvasToContainer(){
      resizeCanvas();
    }
    // ç«‹å³é€‚é…
    fitCanvasToContainer();

    // é˜²æ­¢é€‰ä¸­ canvas æ–‡æœ¬
    document.addEventListener('selectstart', e => { if (e.target === canvas) e.preventDefault(); });
    window.addEventListener('resize', resizeCanvas);

    // è°ƒè¯•ä¸å¤–éƒ¨è®¿é—®ç‚¹
    window._sim = { getGrid: () => grid, getTemp: () => temp, EL, COLORS, PARAM, draw };

  </script>
</body>
</html>
