<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>ç‰©ç†æ²™ç›’ Â· è§†è§‰ç¼–ç»‡åœº</title>
  <style>
    /* --- è§†è§‰ä¸æ’ç‰ˆï¼ˆéµå¾ªç”¨æˆ·çš„ç¾å­¦æŒ‡å¼•ï¼‰ --- */
    :root{
      --bg:#f7f8fa;
      --panel:#ffffff;
      --muted:#7a8691;
      --ink:#1f2a37;
      --accent:#2563eb;
      --soft:#eef2ff;
      --canvas-bg:#0f1220;
      --glass: rgba(255,255,255,0.6);
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, "PingFang SC", "Hiragino Sans GB", "Microsoft Yahei", "Helvetica Neue", Arial;
      background:linear-gradient(180deg,var(--bg) 0%, #eef3ff 100%);
      color:var(--ink);
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
      padding:32px;
      display:flex;
      justify-content:center;
      align-items:flex-start;
    }

    .stage {
      width:1100px;
      max-width:calc(100% - 48px);
      display:grid;
      grid-template-columns: 320px 1fr;
      gap:24px;
      align-items:start;
    }

    header {
      grid-column: 1 / -1;
      text-align:left;
      margin-bottom:6px;
    }

    h1{
      font-size:28px;
      line-height:1;
      margin:0 0 6px 0;
      font-weight:700;
      letter-spacing: -0.02em;
    }
    p.lead{
      margin:0;
      color:var(--muted);
      font-size:13px;
    }

    /* å·¦ä¾§æ§åˆ¶æ ï¼ˆå‘¼å¸ä¸ºç•™ç™½ï¼‰ */
    .controls {
      background:var(--panel);
      border-radius:14px;
      padding:18px;
      box-shadow:0 8px 30px rgba(18,30,50,0.06);
      display:flex;
      flex-direction:column;
      gap:12px;
    }

    .controls h3{
      margin:0 0 6px 0;
      font-size:14px;
      color:var(--ink);
    }

    .palette{
      display:grid;
      grid-template-columns:repeat(2,1fr);
      gap:8px;
    }
    .btn{
      border:0;
      padding:10px 12px;
      border-radius:10px;
      cursor:pointer;
      display:flex;
      gap:8px;
      align-items:center;
      font-weight:600;
      font-size:13px;
      color:white;
      box-shadow: 0 2px 8px rgba(16,24,40,0.06);
      transition: transform .12s ease, box-shadow .12s ease;
    }
    .btn:active{transform:scale(.99)}
    .btn.small{font-size:12px;padding:8px;border-radius:8px}
    .btn.toggled{outline:3px solid rgba(37,99,235,0.12); transform:translateY(-2px)}

    .e-water{background:linear-gradient(180deg,#4aa3ff,#2b7ed9)}
    .e-sand{background:linear-gradient(180deg,#f6b35b,#e08b2b)}
    .e-stone{background:linear-gradient(180deg,#a7afb6,#7f868b)}
    .e-wood{background:linear-gradient(180deg,#8b5a2b,#a86b3b)}
    .e-fire{background:linear-gradient(180deg,#ff6b4a,#e0422a)}
    .e-steam{background:linear-gradient(180deg,#dfe7ee,#ffffff); color:#1f2a37}
    .e-ice{background:linear-gradient(180deg,#bfe7ff,#9fd6ff); color:#05314a}

    .controls .row{display:flex;gap:8px;flex-wrap:wrap}
    .label{font-size:12px;color:var(--muted);margin-bottom:6px}

    .sliders{
      background:var(--soft);
      padding:10px;border-radius:10px;
      display:flex;flex-direction:column;gap:8px;
    }

    /* ç”»å¸ƒé¢æ¿ï¼ˆä¸»å±å¹•å ä¸€é¢˜å½“ä»¤ï¼‰*/
    .canvas-panel{
      background:var(--panel);
      border-radius:14px;
      padding:14px;
      box-shadow:0 8px 30px rgba(18,30,50,0.06);
      display:flex;
      flex-direction:column;
      gap:12px;
    }

    .canvas-top{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:8px;
    }
    .controls-compact{display:flex;gap:8px;align-items:center}
    .kbd{background:#111827;color:white;padding:6px 8px;border-radius:8px;font-size:12px}

    .canvas-wrap{
      background:var(--canvas-bg);
      border-radius:10px;
      padding:12px;
      display:flex;
      justify-content:center;
      align-items:center;
      position:relative;
      box-shadow: inset 0 1px 0 rgba(255,255,255,0.02);
    }

    canvas#sim {
      image-rendering: pixelated;
      border-radius:6px;
      background:linear-gradient(180deg,#0b0d14 0%, #101220 100%);
      box-shadow: 0 10px 30px rgba(7,10,20,0.6);
      display:block;
      max-width:100%;
      height:auto;
    }

    .legend{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
      font-size:12px;color:var(--muted)
    }
    .legend .item{display:flex;gap:8px;align-items:center;background:rgba(255,255,255,0.02);padding:6px 8px;border-radius:8px}
    .swatch{width:14px;height:14px;border-radius:3px;box-shadow: inset 0 -1px 0 rgba(0,0,0,0.2)}

    /* è¯´æ˜é¢æ¿ */
    .notes{
      grid-column:1 / -1;
      background:linear-gradient(180deg, rgba(255,255,255,0.9), rgba(255,255,255,0.96));
      border-radius:12px;padding:14px;color:var(--muted);font-size:13px;
      box-shadow:0 6px 20px rgba(16,24,40,0.04)
    }

    footer{margin-top:18px;text-align:center;color:var(--muted);font-size:12px}
    @media (max-width:980px){
      .stage{grid-template-columns:1fr; gap:12px}
      .controls{order:2}
      .canvas-panel{order:1}
    }
  </style>
</head>
<body>
  <main class="stage" aria-labelledby="title">
    <header>
      <h1 id="title">ç‰©ç†æ²™ç›’ Â· è§†è§‰ç¼–ç»‡åœº</h1>
      <p class="lead">å…‰ä¸ç•™ç™½ï¼Œå¼ åŠ›ä¸æµâ€”â€”2Dç«–ç›´åˆ‡é¢ç‰©ç†æ²™ç›’ã€‚å…ƒç´ ï¼šæ°´ / æ²™ / çŸ³ / æœ¨ï¼ˆå«æ¤ç‰©ç‰¹æ€§ï¼‰ / ç« / è’¸æ±½ / å†° â€”â€” åŒ…å«é‡åŠ›ã€çƒ­ä¼ å¯¼ã€çŠ¶æ€å˜åŒ–ä¸åŸºæœ¬ç”Ÿæ€è§„å¾‹ã€‚</p>
    </header>

    <!-- å·¦ï¼šæ§åˆ¶ -->
    <aside class="controls" aria-label="æ§åˆ¶é¢æ¿">
      <div>
        <h3>é€‰æ‹©å…ƒç´ </h3>
        <div class="palette" role="list">
          <button class="btn e-water" data-el="water" role="listitem">ğŸ’§ æ°´</button>
          <button class="btn e-sand" data-el="sand" role="listitem">ğŸŒ¾ æ²™</button>
          <button class="btn e-stone" data-el="stone" role="listitem">ğŸª¨ çŸ³å¤´</button>
          <button class="btn e-wood" data-el="wood" role="listitem">ğŸªµ æœ¨æ</button>
          <button class="btn e-fire" data-el="fire" role="listitem">ğŸ”¥ ç«ç„°</button>
          <button class="btn e-steam" data-el="steam" role="listitem">â˜ï¸ è’¸æ±½</button>
          <button class="btn e-ice" data-el="ice" role="listitem">â„ï¸ å†°</button>
        </div>
      </div>

      <div>
        <h3>ç”»å¸ƒæ§åˆ¶</h3>
        <div class="row">
          <button id="eraseBtn" class="btn small" style="background:#6b7280">æ©¡çš®</button>
          <button id="clearBtn" class="btn small" style="background:#ef4444">æ¸…å±</button>
          <button id="pauseBtn" class="btn small" style="background:#2563eb">æš‚åœ</button>
        </div>
      </div>

      <div>
        <h3>å‚æ•°</h3>
        <div class="sliders">
          <div class="label">é‡åŠ›ï¼š<span id="gravityVal">0.6</span></div>
          <input id="gravity" type="range" min="0" max="1.2" step="0.05" value="0.6">
          <div class="label">ç²’å­å°ºå¯¸ï¼ˆåƒç´ ï¼‰ï¼š<span id="psizeVal">4</span></div>
          <input id="psize" type="range" min="2" max="8" step="1" value="4">
          <div class="label">ç¯å¢ƒæ¸©åº¦ï¼ˆåˆå§‹ï¼‰ï¼š<span id="ambientVal">20</span> Â°C</div>
          <input id="ambient" type="range" min="-20" max="120" step="1" value="20">
        </div>
      </div>

      <div>
        <h3>æç¤º</h3>
        <div style="color:var(--muted);font-size:13px;line-height:1.45">
          - å·¦é”®ç»˜åˆ¶æ‰€é€‰å…ƒç´ ï¼›å³é”®å–æ ·ï¼ˆæŒ‰ä½ Shift åˆ‡æ¢æ©¡çš®ï¼‰ã€‚<br>
          - æ–°å…ƒç´ ä¸ä¼šè¦†ç›–å·²æœ‰å…ƒç´ ï¼Œä¼šè‡ªåŠ¨åœ¨æœ€è¿‘ç©ºç™½å¤„ç”Ÿæˆã€‚<br>
          - æ‰€æœ‰å…ƒç´ éƒ½ä¼šå—é‡åŠ›å½±å“è½ä¸‹ï¼ŒåŒ…æ‹¬çŸ³å¤´å’Œæœ¨æã€‚<br>
          - æœ¨æèåˆäº†æ¤ç‰©ç‰¹æ€§ï¼Œéœ€è¦æ°´åˆ†ç»´æŒï¼Œä¼šæ¶ˆè€—é‚»è¿‘æ°´æºï¼›ç¼ºæ°´æ—¶æ­»äº¡ã€‚ç«ç„°å¯ç‚¹ç‡ƒæœ¨æã€‚<br>
          - å†°ä¼šéšæ¸©åº¦è½¬ä¸ºæ°´æˆ–è’¸æ±½ï¼›é€‚å½“é™ä½ç²’å­å°ºå¯¸å¯è·å¾—æ›´ç»†è…»çš„æµä½“è¡¨ç°ã€‚
        </div>
      </div>
    </aside>

    <!-- å³ï¼šç”»å¸ƒ -->
    <section class="canvas-panel" aria-label="æ¨¡æ‹Ÿç”»å¸ƒ">
      <div class="canvas-top">
        <div>
          <strong>æ¨¡æ‹Ÿç”»å¸ƒ</strong>
          <div style="font-size:12px;color:var(--muted)">ç«–ç›´åˆ‡é¢ Â· 2D ç²’å­æ ¼</div>
        </div>
        <div class="controls-compact">
          <div class="kbd" id="modeDisplay">æ¨¡å¼ï¼šç»˜åˆ¶</div>
          <div style="width:12px"></div>
          <div class="legend" aria-hidden="true">
            <div class="item"><div class="swatch" style="background:#4aa3ff"></div>æ°´</div>
            <div class="item"><div class="swatch" style="background:#f6b35b"></div>æ²™</div>
            <div class="item"><div class="swatch" style="background:#a7afb6"></div>çŸ³</div>
            <div class="item"><div class="swatch" style="background:#8b5a2b"></div>æœ¨</div>
            <div class="item"><div class="swatch" style="background:#ff6b4a"></div>ç«</div>
            <div class="item"><div class="swatch" style="background:#dfe7ee"></div>è’¸æ±½</div>
            <div class="item"><div class="swatch" style="background:#bfe7ff"></div>å†°</div>
          </div>
        </div>
      </div>

      <div class="canvas-wrap" id="canvasWrap">
        <canvas id="sim" width="800" height="600" aria-label="ç‰©ç†æ²™ç›’ç”»å¸ƒ"></canvas>
      </div>
    </section>

    <section class="notes" aria-label="è¯´æ˜">
      <strong>ç‰©ç†è§„åˆ™ï¼ˆæ‘˜è¦ï¼‰</strong>
      <ul>
        <li>é‡åŠ›ï¼šæ‰€æœ‰å…ƒç´ éƒ½ä¼šå—é‡åŠ›å½±å“è½ä¸‹ï¼ŒåŒ…æ‹¬çŸ³å¤´å’Œæœ¨æã€‚</li>
        <li>çƒ­åŠ›ï¼šç«ç„°æé«˜å‘¨å›´æ¸©åº¦ï¼›æ¸©åº¦é©±åŠ¨ç›¸å˜ï¼šå†°â†’æ°´â†’è’¸æ±½ï¼›è’¸æ±½é‡å†·å‡ç»“ä¸ºæ°´ã€‚</li>
        <li>æœ¨æç‰¹æ€§ï¼šèåˆäº†æ¤ç‰©ç‰¹æ€§ï¼Œéœ€è¦æ°´åˆ†ç»´æŒç”Ÿå‘½ï¼Œä¼šæ¶ˆè€—é‚»è¿‘æ°´æºï¼›ç¼ºæ°´æ—¶æ­»äº¡ã€‚ç«ç„°å¯ç‚¹ç‡ƒæœ¨æã€‚</li>
        <li>å…ƒç´ æ”¾ç½®ï¼šæ–°å…ƒç´ ä¸ä¼šè¦†ç›–å·²æœ‰å…ƒç´ ï¼Œä¼šè‡ªåŠ¨åœ¨æœ€è¿‘çš„ç©ºç™½å¤„ç”Ÿæˆã€‚</li>
        <li>è¾¹ç•Œï¼šç”»å¸ƒå››å‘¨ä¸ºå®ç‰©è¾¹ç•Œï¼ˆæœ€ä¸‹æ–¹ä¸å¯ç©¿è¶Šï¼Œå…ƒç´ ä¸èƒ½æ‰å‡ºç”»å¸ƒï¼‰ã€‚</li>
      </ul>
    </section>

    <footer>è®¾è®¡ Â· è§†è§‰ç¼–ç»‡åœº â€” ä»¥ç•™ç™½ä¸ºæ°§ï¼Œé‡è¦åˆ™å¤§ï¼ŒæµåŠ¨æœ‰èŠ‚</footer>
  </main>

  <script>

    /* -------- æ¨¡å‹/å‚æ•° -------- */
    const canvas = document.getElementById('sim');
    const ctx = canvas.getContext('2d');

    // åŠ¨æ€å‚æ•°ï¼ˆä¼šåœ¨ UI æ”¹å˜æ—¶æ›´æ–°ï¼‰
    let PARAM = {
      particleSize: 4,         // åƒç´ 
      gravity: 0.6,            // é‡åŠ›å¼ºåº¦ï¼ˆå½±å“ä¸‹è½æ¦‚ç‡ï¼‰
      ambientTemp: 20,         // åˆå§‹ç¯å¢ƒæ¸©åº¦ï¼ˆÂ°Cï¼‰
      fpsLimit: 60
    };

    // å…ƒç´ ç±»å‹
    const EL = {
      EMPTY: 0, SAND: 1, WATER: 2, STONE: 3, WOOD: 4,
      FIRE: 5, STEAM: 6, ICE: 7
    };

    const COLORS = {
      [EL.EMPTY]: '#0f1220',
      [EL.SAND]: '#f6b35b',
      [EL.WATER]: '#4aa3ff',
      [EL.STONE]: '#a7afb6',
      [EL.WOOD]: '#8b5a2b',
      [EL.FIRE]: '#ff6b4a',
      [EL.STEAM]: '#dfe7ee',
      [EL.ICE]: '#bfe7ff'
    };

    // ç½‘æ ¼ï¼ˆåˆ— x è¡Œï¼‰
    let COLS = Math.floor(canvas.width / PARAM.particleSize);
    let ROWS = Math.floor(canvas.height / PARAM.particleSize);

    // æ’å€¼å‡½æ•°ï¼ˆå®‰å…¨ï¼‰
    const clamp = (v, a, b) => Math.max(a, Math.min(b, v|0));

    // ç½‘æ ¼æ•°ç»„ï¼š grid[c][r]
    let grid = [];
    let temp = [];            // æ¸©åº¦ï¼ˆÂ°Cï¼‰æ …æ ¼
    let fireLife = [];        // ç«ç„°ç”Ÿå‘½å‘¨æœŸ
    let woodHydration = [];   // æœ¨ææ°´åˆ†å€¼ï¼ˆèåˆæ¤ç‰©ç‰¹æ€§ï¼‰
    let woodWaterConsumed = []; // æœ¨æç´¯ç§¯æ¶ˆè€—æ°´é‡

    function allocGrid() {
      COLS = Math.max(8, Math.floor(canvas.width / PARAM.particleSize));
      ROWS = Math.max(8, Math.floor(canvas.height / PARAM.particleSize));
      grid = new Array(COLS);
      temp = new Array(COLS);
      fireLife = new Array(COLS);
      woodHydration = new Array(COLS);
      woodWaterConsumed = new Array(COLS);
      for (let x = 0; x < COLS; x++) {
        grid[x] = new Array(ROWS).fill(EL.EMPTY);
        temp[x] = new Array(ROWS).fill(PARAM.ambientTemp);
        fireLife[x] = new Array(ROWS).fill(0);
        woodHydration[x] = new Array(ROWS).fill(0);
        woodWaterConsumed[x] = new Array(ROWS).fill(0);
      }
    }

    allocGrid();

    /* -------- UI è¿æ¥ -------- */
    const buttons = document.querySelectorAll('.palette .btn');
    let current = EL.SAND;
    buttons.forEach(b=>{
      b.addEventListener('click', ()=>{
        buttons.forEach(x=>x.classList.remove('toggled'));
        b.classList.add('toggled');
        const key = b.dataset.el;
        const map = {sand:EL.SAND, water:EL.WATER, stone:EL.STONE, wood:EL.WOOD, fire:EL.FIRE, steam:EL.STEAM, ice:EL.ICE};
        current = map[key] ?? EL.SAND;
      });
    });
    // è®¾ç½®é»˜è®¤
    document.querySelector('.btn[data-el="sand"]').classList.add('toggled');

    // æ§åˆ¶æŒ‰é’®
    const eraseBtn = document.getElementById('eraseBtn');
    const clearBtn = document.getElementById('clearBtn');
    const pauseBtn = document.getElementById('pauseBtn');
    const modeDisplay = document.getElementById('modeDisplay');

    let eraseMode = false;
    let paused = false;
    eraseBtn.addEventListener('click', ()=>{ eraseMode = !eraseMode; modeDisplay.textContent = eraseMode ? 'æ¨¡å¼ï¼šæ©¡çš®' : 'æ¨¡å¼ï¼šç»˜åˆ¶'; eraseBtn.style.opacity = eraseMode ? '1' : '0.7' });
    clearBtn.addEventListener('click', ()=>{ allocGrid(); draw(); });
    pauseBtn.addEventListener('click', ()=>{ paused = !paused; pauseBtn.textContent = paused ? 'ç»§ç»­' : 'æš‚åœ'; });

    // sliders
    const gravitySlider = document.getElementById('gravity');
    const psizeSlider = document.getElementById('psize');
    const ambientSlider = document.getElementById('ambient');
    const gravityVal = document.getElementById('gravityVal');
    const psizeVal = document.getElementById('psizeVal');
    const ambientVal = document.getElementById('ambientVal');

    gravitySlider.value = PARAM.gravity; gravityVal.textContent = PARAM.gravity;
    psizeSlider.value = PARAM.particleSize; psizeVal.textContent = PARAM.particleSize;
    ambientSlider.value = PARAM.ambientTemp; ambientVal.textContent = PARAM.ambientTemp;

    gravitySlider.addEventListener('input', e=>{ PARAM.gravity = parseFloat(e.target.value); gravityVal.textContent = PARAM.gravity; });
    ambientSlider.addEventListener('input', e=>{ PARAM.ambientTemp = parseFloat(e.target.value); ambientVal.textContent = PARAM.ambientTemp; });
    psizeSlider.addEventListener('input', e=>{
      PARAM.particleSize = parseInt(e.target.value);
      psizeVal.textContent = PARAM.particleSize;
      allocGrid();
      draw();
    });

    /* -------- é¼ æ ‡ç»˜åˆ¶äº¤äº’ -------- */
    let drawing = false;
    let last = null;
    const canvasRect = () => canvas.getBoundingClientRect();

    function toCell(clientX, clientY) {
      const rect = canvasRect();
      const cx = clientX - rect.left;
      const cy = clientY - rect.top;
      const col = clamp(Math.floor(cx / PARAM.particleSize), 0, COLS - 1);
      const row = clamp(Math.floor(cy / PARAM.particleSize), 0, ROWS - 1);
      return {col,row};
    }

    canvas.addEventListener('pointerdown', e=>{
      drawing = true;
      canvas.setPointerCapture(e.pointerId);
      if (e.button === 2) { // right-click sample
        const {col,row} = toCell(e.clientX, e.clientY);
        current = grid[col][row] || current;
        // find button and toggle
        const reverse = { [EL.SAND]:'sand', [EL.WATER]:'water', [EL.STONE]:'stone', [EL.WOOD]:'wood', [EL.FIRE]:'fire', [EL.STEAM]:'steam', [EL.ICE]:'ice' };
        const key = reverse[current];
        if (key){
          buttons.forEach(x=>x.classList.remove('toggled'));
          const btn = document.querySelector(`.btn[data-el="${key}"]`);
          if (btn) btn.classList.add('toggled');
        }
      } else {
        handlePaint(e);
      }
    });
    canvas.addEventListener('pointermove', e=>{
      if (drawing) handlePaint(e);
    });
    canvas.addEventListener('pointerup', e=>{
      drawing = false;
      canvas.releasePointerCapture?.(e.pointerId);
      last = null;
    });
    canvas.addEventListener('contextmenu', e=> e.preventDefault());

    function handlePaint(e){
      const {col,row} = toCell(e.clientX, e.clientY);
      if (eraseMode || e.shiftKey) {
        paintBlock(col,row,EL.EMPTY);
      } else {
        paintBlock(col,row,current);
      }
      // draw line from last to avoid gaps
      if (last){
        linePaint(last.col,last.row,col,row,current,(eraseMode|| e.shiftKey));
      }
      last = {col,row};
    }

    // å¯»æ‰¾æœ€è¿‘çš„ç©ºç™½ä½ç½®
    function findNearestEmpty(cx, cy) {
      // å¦‚æœç›®æ ‡ä½ç½®å·²ç»æ˜¯ç©ºçš„ï¼Œç›´æ¥è¿”å›
      if (grid[cx][cy] === EL.EMPTY) {
        return {x: cx, y: cy};
      }
      
      // ä½¿ç”¨BFSå¯»æ‰¾æœ€è¿‘çš„ç©ºç™½ä½ç½®
      const queue = [{x: cx, y: cy, dist: 0}];
      const visited = new Set();
      visited.add(`${cx},${cy}`);
      
      const directions = [
        {dx: 0, dy: 1},  // ä¸‹
        {dx: 1, dy: 0},  // å³
        {dx: 0, dy: -1}, // ä¸Š
        {dx: -1, dy: 0}, // å·¦
        {dx: 1, dy: 1},  // å³ä¸‹
        {dx: -1, dy: 1}, // å·¦ä¸‹
        {dx: 1, dy: -1}, // å³ä¸Š
        {dx: -1, dy: -1} // å·¦ä¸Š
      ];
      
      while (queue.length > 0) {
        const {x, y} = queue.shift();
        
        // æ£€æŸ¥æ˜¯å¦æ˜¯ç©ºç™½ä½ç½®
        if (grid[x][y] === EL.EMPTY) {
          return {x, y};
        }
        
        // æ·»åŠ ç›¸é‚»ä½ç½®åˆ°é˜Ÿåˆ—
        for (const {dx, dy} of directions) {
          const nx = x + dx;
          const ny = y + dy;
          const key = `${nx},${ny}`;
          
          if (nx >= 0 && nx < COLS && ny >= 0 && ny < ROWS && !visited.has(key)) {
            visited.add(key);
            queue.push({x: nx, y: ny});
          }
        }
      }
      
      // å¦‚æœæ²¡æœ‰æ‰¾åˆ°ç©ºç™½ä½ç½®ï¼Œè¿”å›åŸå§‹ä½ç½®
      return {x: cx, y: cy};
    }

    function paintBlock(cx,cy,el){
      // å¦‚æœæ˜¯æ©¡çš®æ¨¡å¼ï¼Œç›´æ¥æ¸…é™¤
      if (el === EL.EMPTY) {
        const r = Math.max(0, Math.floor(PARAM.particleSize/2));
        for (let dx=-r; dx<=r; dx++){
          for (let dy=-r; dy<=r; dy++){
            const x = cx+dx, y = cy+dy;
            if (x>=0 && x<COLS && y>=0 && y<ROWS){
              grid[x][y] = EL.EMPTY;
              fireLife[x][y] = 0;
              woodHydration[x][y] = 0;
              woodWaterConsumed[x][y] = 0;
            }
          }
        }
        return;
      }
      
      // å¦åˆ™ï¼Œå¯»æ‰¾æœ€è¿‘çš„ç©ºç™½ä½ç½®æ”¾ç½®å…ƒç´ 
      const r = Math.max(0, Math.floor(PARAM.particleSize/2));
      for (let dx=-r; dx<=r; dx++){
        for (let dy=-r; dy<=r; dy++){
          const x = cx+dx, y = cy+dy;
          if (x>=0 && x<COLS && y>=0 && y<ROWS){
            // å¯»æ‰¾æœ€è¿‘çš„ç©ºç™½ä½ç½®
            const emptyPos = findNearestEmpty(x, y);
            if (emptyPos.x >= 0 && emptyPos.x < COLS && emptyPos.y >= 0 && emptyPos.y < ROWS) {
              grid[emptyPos.x][emptyPos.y] = el;
              if (el === EL.FIRE) fireLife[emptyPos.x][emptyPos.y] = 120;
              if (el === EL.WOOD) {
                woodHydration[emptyPos.x][emptyPos.y] = 60; // åˆå§‹æ°´åˆ†
                woodWaterConsumed[emptyPos.x][emptyPos.y] = 0; // åˆå§‹ç´¯ç§¯æ¶ˆè€—æ°´é‡ä¸º0
              }
              if (el === EL.ICE) temp[emptyPos.x][emptyPos.y] = Math.min(temp[emptyPos.x][emptyPos.y], 0);
              if (el === EL.WATER) temp[emptyPos.x][emptyPos.y] = Math.max(temp[emptyPos.x][emptyPos.y], PARAM.ambientTemp);
            }
          }
        }
      }
    }

    function linePaint(x0,y0,x1,y1,el,isErase=false){
      const dx = Math.abs(x1-x0), dy = Math.abs(y1-y0);
      const sx = x0<x1 ? 1 : -1, sy = y0<y1 ? 1 : -1;
      let err = dx-dy;
      let x=x0,y=y0;
      while(true){
        paintBlock(x,y,isErase?EL.EMPTY:el);
        if (x===x1 && y===y1) break;
        const e2 = 2*err;
        if (e2>-dy){ err-=dy; x+=sx; }
        if (e2<dx){ err+=dx; y+=sy; }
      }
    }

    /* -------- ç‰©ç†è§„åˆ™å®ç° -------- */

    // æ¸©åº¦é˜ˆå€¼ï¼ˆè¿‘ä¼¼æ¨¡å‹ï¼‰
    const MELT_TEMP = 2;     // å†°â†’æ°´ï¼ˆÂ°Cï¼‰
    const BOIL_TEMP = 90;    // æ°´â†’è’¸æ±½ï¼ˆÂ°Cï¼‰
    const CONDENSE_TEMP = 50;// è’¸æ±½â†’æ°´ï¼ˆÂ°Cï¼‰

    // æ¯å¸§æ›´æ–°ï¼ˆæ‰«æä»ä¸‹åˆ°ä¸Šï¼šé‡åŠ›ï¼‰
    function step() {
      // 1) æ¸©åº¦æ‰©æ•£ä¸è¡°å‡ï¼ˆåŸºç¡€ç¯å¢ƒå›å½’ï¼‰
      const ambient = PARAM.ambientTemp;
      // diffuse: simple kernel; create new temp buffer to avoid intra-frame effects
      const newTemp = new Array(COLS);
      for (let x=0;x<COLS;x++){
        newTemp[x] = new Array(ROWS);
        for (let y=0;y<ROWS;y++){
          newTemp[x][y] = temp[x][y];
        }
      }
      for (let x=0;x<COLS;x++){
        for (let y=0;y<ROWS;y++){
          // diffusion with neighbors
          let t = temp[x][y]*0.6;
          let count = 0.6;
          const nbs = [[1,0],[-1,0],[0,1],[0,-1]];
          for (const [dx,dy] of nbs){
            const nx=x+dx, ny=y+dy;
            if (nx>=0 && nx<COLS && ny>=0 && ny<ROWS){
              t += temp[nx][ny]*0.1;
              count += 0.1;
            }
          }
          // relax towards ambient slightly
          t = t/count;
          t += (ambient - t) * 0.004; // slow ambient blending
          newTemp[x][y] = t;
        }
      }
      // swap temp
      for (let x=0;x<COLS;x++) for (let y=0;y<ROWS;y++) temp[x][y] = newTemp[x][y];

      // 2) main element updates: from bottom-1 up to 0
      for (let y = ROWS - 2; y >= 0; y--) {
        for (let x = 0; x < COLS; x++) {
          const el = grid[x][y];
          if (el === EL.EMPTY) continue;

          switch (el) {
            case EL.SAND:
              updateSand(x,y);
              break;
            case EL.WATER:
              updateWater(x,y);
              break;
            case EL.ICE:
              updateIce(x,y);
              break;
            case EL.FIRE:
              updateFire(x,y);
              break;
            case EL.STEAM:
              updateSteam(x,y);
              break;
            case EL.STONE:
              updateStone(x,y);
              break;
            case EL.WOOD:
              updateWood(x,y);
              break;
            default:
              break;
          }
        }
      }

      // bottom row interactions (y = ROWS - 1)
      for (let x=0;x<COLS;x++){
        if (grid[x][ROWS-1] === EL.FIRE){
          fireLife[x][ROWS-1] -= 4;
          if (fireLife[x][ROWS-1] <= 0) grid[x][ROWS-1] = EL.EMPTY;
        }
      }
    }

    /* --- å…ƒç´ å…·ä½“é€»è¾‘ --- */

    function swap(x1,y1,x2,y2){
      const t = grid[x1][y1];
      grid[x1][y1] = grid[x2][y2];
      grid[x2][y2] = t;
      // swap temp for continuity
      const tt = temp[x1][y1];
      temp[x1][y1] = temp[x2][y2];
      temp[x2][y2] = tt;
      // swap fireLife and woodHydration as well
      const f = fireLife[x1][y1]; fireLife[x1][y1] = fireLife[x2][y2]; fireLife[x2][y2] = f;
      const wh = woodHydration[x1][y1]; woodHydration[x1][y1] = woodHydration[x2][y2]; woodHydration[x2][y2] = wh;
      // swap woodWaterConsumed
      const wc = woodWaterConsumed[x1][y1]; woodWaterConsumed[x1][y1] = woodWaterConsumed[x2][y2]; woodWaterConsumed[x2][y2] = wc;
    }

    function canFallInto(x,y){
      if (y >= ROWS) return false;
      return grid[x][y] === EL.EMPTY || grid[x][y] === EL.STEAM;
    }

    function updateSand(x,y){
      if (y+1 < ROWS){
        const below = grid[x][y+1];
        if (below === EL.EMPTY || below === EL.STEAM){
          swap(x,y,x,y+1);
          return;
        }
        if (below === EL.WATER){
          swap(x,y,x,y+1);
          return;
        }
        // diagonal fallback
        const dirs = Math.random() > 0.5 ? [1,-1] : [-1,1];
        for (const d of dirs){
          const nx = x + d;
          if (nx>=0 && nx<COLS && y+1<ROWS && (grid[nx][y+1] === EL.EMPTY || grid[nx][y+1] === EL.STEAM)){
            swap(x,y,nx,y+1); return;
          }
        }
      }
    }

    function updateWater(x,y){
      if (y+1 < ROWS && (grid[x][y+1] === EL.EMPTY || grid[x][y+1] === EL.STEAM)){
        swap(x,y,x,y+1); return;
      }
      const dir = Math.random() > 0.5 ? 1 : -1;
      if (y+1 < ROWS){
        if (x+dir>=0 && x+dir<COLS && (grid[x+dir][y+1] === EL.EMPTY || grid[x+dir][y+1] === EL.STEAM)){
          swap(x,y,x+dir,y+1); return;
        }
        if (x-dir>=0 && x-dir<COLS && (grid[x-dir][y+1] === EL.EMPTY || grid[x-dir][y+1] === EL.STEAM)){
          swap(x,y,x-dir,y+1); return;
        }
      }
      if (Math.random()>0.4){
        if (x+1<COLS && grid[x+1][y] === EL.EMPTY){ swap(x,y,x+1,y); return; }
      } else {
        if (x-1>=0 && grid[x-1][y] === EL.EMPTY){ swap(x,y,x-1,y); return; }
      }
      if (temp[x][y] >= BOIL_TEMP && Math.random() < 0.12){
        grid[x][y] = EL.STEAM;
        temp[x][y] += 8;
      }
    }

    function updateIce(x,y){
      if (temp[x][y] >= MELT_TEMP){
        grid[x][y] = EL.WATER;
        return;
      }
      if (y+1 < ROWS){
        const below = grid[x][y+1];
        if (below === EL.EMPTY || below === EL.STEAM){
          swap(x,y,x,y+1); return;
        }
        if (below === EL.WATER){
          swap(x,y,x,y+1); return;
        }
        const dirs = Math.random() > 0.5 ? [1,-1] : [-1,1];
        for (const d of dirs){
          const nx = x + d;
          if (nx>=0 && nx<COLS && y+1<ROWS && (grid[nx][y+1] === EL.EMPTY || grid[nx][y+1] === EL.STEAM)){
            swap(x,y,nx,y+1); return;
          }
        }
      }
    }

    function updateSteam(x,y){
      if (y-1 >= 0 && grid[x][y-1] === EL.EMPTY){
        swap(x,y,x,y-1); return;
      }
      if (Math.random() < 0.25){
        const dir = Math.random()>0.5?1:-1;
        const nx = x+dir;
        if (nx>=0 && nx<COLS && grid[nx][y] === EL.EMPTY){ swap(x,y,nx,y); return; }
      }
      if (temp[x][y] <= CONDENSE_TEMP && Math.random() < 0.05){
        grid[x][y] = EL.WATER;
        return;
      }
    }

    function updateFire(x,y){
      fireLife[x][y] -= 2;
      temp[x][y] += 12;
      const neighbors = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[-1,1],[1,-1],[-1,-1]];
      for (const [dx,dy] of neighbors){
        const nx=x+dx, ny=y+dy;
        if (nx>=0 && nx<COLS && ny>=0 && ny<ROWS){
          temp[nx][ny] += 6;
        }
      }
      const topFactor = (y < ROWS*0.15) ? 0.15 : 0.03;
      if (fireLife[x][y] <= 0 || Math.random() < topFactor){
        grid[x][y] = EL.EMPTY; fireLife[x][y]=0; return;
      }

      if (y-1 >= 0 && grid[x][y-1] === EL.EMPTY){
        grid[x][y-1] = EL.FIRE; fireLife[x][y-1] = Math.max(20, fireLife[x][y]-8);
        grid[x][y] = EL.EMPTY; fireLife[x][y]=0;
        return;
      }

      let sideChance = (y < ROWS*0.15) ? 0.08 : 0.28;
      if (Math.random() < sideChance){
        const dir = Math.random()>0.5?1:-1;
        const nx = x+dir;
        if (nx>=0 && nx<COLS && grid[nx][y] === EL.EMPTY){
          grid[nx][y] = EL.FIRE; fireLife[nx][y] = Math.max(20, fireLife[x][y]-10);
          grid[x][y] = EL.EMPTY; fireLife[x][y]=0;
          return;
        }
      }

      for (const [dx,dy] of [[1,0],[-1,0],[0,1],[0,-1],[1,1],[-1,1],[1,-1],[-1,-1]]){
        const nx = x+dx, ny = y+dy;
        if (nx<0||nx>=COLS||ny<0||ny>=ROWS) continue;
        const nearby = grid[nx][ny];
        if (nearby === EL.WATER && Math.random() < 0.18){
          grid[nx][ny] = EL.STEAM;
          temp[nx][ny] += 18;
        } else if (nearby === EL.WOOD && Math.random() < 0.25){
          grid[nx][ny] = EL.FIRE; fireLife[nx][ny] = 140;
        } else if (nearby === EL.STONE){
          temp[nx][ny] += 6;
        } else {
          if (nearby === EL.EMPTY && Math.random() < 0.02){
            grid[nx][ny] = EL.FIRE; fireLife[nx][ny] = 50;
          }
        }
      }
    }

    // çŸ³å¤´ç°åœ¨ä¹Ÿä¼šä¸‹è½
    function updateStone(x,y){
      if (y+1 < ROWS){
        const below = grid[x][y+1];
        if (below === EL.EMPTY || below === EL.STEAM){
          swap(x,y,x,y+1);
          return;
        }
        // çŸ³å¤´æ¯”æ°´é‡ï¼Œå¯ä»¥æ²‰å…¥æ°´ä¸­
        if (below === EL.WATER){
          swap(x,y,x,y+1);
          return;
        }
        // diagonal fallback
        const dirs = Math.random() > 0.5 ? [1,-1] : [-1,1];
        for (const d of dirs){
          const nx = x + d;
          if (nx>=0 && nx<COLS && y+1<ROWS && (grid[nx][y+1] === EL.EMPTY || grid[nx][y+1] === EL.STEAM || grid[nx][y+1] === EL.WATER)){
            swap(x,y,nx,y+1); return;
          }
        }
      }
    }

    // æœ¨æèåˆäº†æ¤ç‰©ç‰¹æ€§
    function updateWood(x,y){
      // æœ¨ææ¶ˆè€—æ°´åˆ†
      const waterConsumed = 0.002;
      woodHydration[x][y] = woodHydration[x][y] - waterConsumed;
      
      // å°è¯•å¸æ”¶é‚»è¿‘æ°´åˆ†
      const nbs = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[-1,1],[1,-1],[-1,-1]];
      let waterAbsorbed = 0;
      for (const [dx,dy] of nbs){
        const nx = x+dx, ny = y+dy;
        if (nx<0||nx>=COLS||ny<0||ny>=ROWS) continue;
        if (grid[nx][ny] === EL.WATER && Math.random() < 0.35){
          grid[nx][ny] = EL.EMPTY;
          woodHydration[x][y] += 8;
          temp[nx][ny] -= 2;
          waterAbsorbed++;
          break;
        }
      }
      
      // æ ¹æ®æ¶ˆè€—çš„æ°´é‡ç”Ÿé•¿ï¼ˆæ¯æ¶ˆè€—1å•ä½æ°´ï¼Œç”Ÿé•¿2ä¸ªæ–°æœ¨æï¼‰
      woodWaterConsumed[x][y] += waterConsumed;
      
      // å½“ç´¯ç§¯æ¶ˆè€—çš„æ°´é‡è¾¾åˆ°1å•ä½æ—¶ï¼Œç”Ÿé•¿2ä¸ªæ–°æœ¨æ
      if (woodWaterConsumed[x][y] >= 1) {
        // è·å–æ‰€æœ‰å¯èƒ½çš„ç”Ÿé•¿ä½ç½®
        const growDirs = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[-1,1],[1,-1],[-1,-1]];
        const possiblePositions = [];
        
        for (const [dx,dy] of growDirs) {
          const nx = x+dx, ny = y+dy;
          if (nx>=0 && nx<COLS && ny>=0 && ny<ROWS && grid[nx][ny] === EL.EMPTY) {
            possiblePositions.push({x: nx, y: ny});
          }
        }
        
        // éšæœºé€‰æ‹©ä½ç½®ç”Ÿé•¿
        if (possiblePositions.length > 0) {
          const shuffled = [...possiblePositions].sort(() => Math.random() - 0.5);
          const growCount = Math.min(2, shuffled.length); // ç”Ÿé•¿2ä¸ªæ–°æœ¨æ
          
          for (let i = 0; i < growCount; i++) {
            const pos = shuffled[i];
            grid[pos.x][pos.y] = EL.WOOD;
            woodHydration[pos.x][pos.y] = woodHydration[x][y] * 0.8; // æ–°æœ¨æçš„æ°´åˆ†æ˜¯æ¯ä½“çš„80%
            woodWaterConsumed[pos.x][pos.y] = 0; // æ–°æœ¨æçš„ç´¯ç§¯æ¶ˆè€—æ°´é‡ä¸º0
          }
        }
        
        // é‡ç½®ç´¯ç§¯æ¶ˆè€—çš„æ°´é‡
        woodWaterConsumed[x][y] = 0;
      }
      
      // å¦‚æœæ°´åˆ†è¿‡ä½ï¼Œæœ¨ææ­»äº¡ï¼ˆå˜ä¸ºç©ºï¼‰
      if (woodHydration[x][y] <= 0){
        grid[x][y] = EL.EMPTY;
        woodHydration[x][y] = 0;
        woodWaterConsumed[x][y] = 0;
        return;
      }
      
      // æœ¨æä¹Ÿä¼šä¸‹è½
      if (y+1 < ROWS){
        const below = grid[x][y+1];
        if (below === EL.EMPTY || below === EL.STEAM){
          swap(x,y,x,y+1);
          return;
        }
        if (below === EL.WATER){
          swap(x,y,x,y+1);
          return;
        }
        // diagonal fallback
        const dirs = Math.random() > 0.5 ? [1,-1] : [-1,1];
        for (const d of dirs){
          const nx = x + d;
          if (nx>=0 && nx<COLS && y+1<ROWS && (grid[nx][y+1] === EL.EMPTY || grid[nx][y+1] === EL.STEAM || grid[nx][y+1] === EL.WATER)){
            swap(x,y,nx,y+1); return;
          }
        }
      }
      
      // å¦‚æœé™„è¿‘æœ‰ç«ï¼Œå¯èƒ½è¢«ç‚¹ç‡ƒ
      for (const [dx,dy] of [[1,0],[-1,0],[0,1],[0,-1]]){
        const nx = x+dx, ny = y+dy;
        if (nx<0||nx>=COLS||ny<0||ny>=ROWS) continue;
        if (grid[nx][ny] === EL.FIRE && Math.random() < 0.35){
          grid[x][y] = EL.FIRE; fireLife[x][y] = 100; return;
        }
      }
    }

    /* -------- ç»˜åˆ¶ -------- */
    function draw(){
      ctx.clearRect(0,0,canvas.width,canvas.height);
      const ps = PARAM.particleSize;
      ctx.fillStyle = '#0b0d14';
      ctx.fillRect(0,0,canvas.width,canvas.height);

      for (let x=0;x<COLS;x++){
        for (let y=0;y<ROWS;y++){
          const el = grid[x][y];
          if (el === EL.EMPTY) continue;
          let col = COLORS[el] ?? '#ffffff';
          if (el === EL.FIRE){
            const life = clamp(fireLife[x][y],0,160);
            const t = life/160;
            const r = Math.floor(255 * (0.6 + 0.4*t));
            const g = Math.floor(80 * (0.4 + 0.6*t));
            const b = Math.floor(30 * (0.1 + 0.1*t));
            col = `rgb(${r},${g},${b})`;
          } else if (el === EL.ICE){
            const tt = clamp((temp[x][y]+20)/120, 0, 1);
            const mix = Math.floor(200 + 55*(1-tt));
            col = `rgb(${mix}, ${230}, ${255})`;
          } else if (el === EL.WATER){
            const tt = clamp((temp[x][y]-PARAM.ambientTemp)/60, -1, 1);
            if (tt > 0.6) col = '#a7e0ff';
            else if (tt < -0.5) col = '#2a8bd6';
            else col = COLORS[el];
          } else if (el === EL.WOOD){
            // æ ¹æ®æ°´åˆ†æ˜¾ç¤ºä¸åŒé¢œè‰²
            const h = clamp(woodHydration[x][y]/80, 0, 1);
            const r = Math.floor(139 * (0.7 + 0.3*(1-h)));
            const g = Math.floor(90 * h + 50*(1-h));
            const b = Math.floor(43 * (0.5 + 0.5*h));
            col = `rgb(${r},${g},${b})`;
          } else {
            col = COLORS[el];
          }

          ctx.fillStyle = col;
          ctx.fillRect(x*ps, y*ps, ps, ps);
        }
      }
    }

    /* -------- ä¸»å¾ªç¯ -------- */
    let lastTime = performance.now();
    function tick(time){
      if (!paused){
        if (time - lastTime > (1000 / PARAM.fpsLimit)){
          step();
          draw();
          lastTime = time;
        }
      }
      requestAnimationFrame(tick);
    }
    requestAnimationFrame(tick);

    /* -------- åˆå§‹åŒ–ï¼šå°æ¼”ç¤ºï¼Œæ·»åŠ ä¸€äº› stones äºåº•éƒ¨è¾¹ç•Œï¼ˆå¯æ³¨é‡Šï¼‰ -------- */
    (function seed(){
      const base = ROWS - 1;
      for (let x=0;x<COLS;x+=2){
        if (Math.random() < 0.6){
          grid[x][base] = EL.STONE;
          temp[x][base] = PARAM.ambientTemp;
        }
      }
    })();

    /* -------- é€‚é…çª—å£å’Œé«˜DPI -------- */
    function resizeCanvas(){
      const dpr = window.devicePixelRatio || 1;
      const rect = canvas.getBoundingClientRect();
      canvas.width = Math.floor(rect.width * dpr);
      canvas.height = Math.floor(rect.height * dpr);
      ctx.setTransform(dpr,0,0,dpr,0,0);
      allocGrid();
      draw();
    }

    function fitCanvasToContainer(){
      resizeCanvas();
    }
    fitCanvasToContainer();

    document.addEventListener('selectstart', e => { if (e.target === canvas) e.preventDefault(); });

    window.addEventListener('resize', resizeCanvas);

    window._sim = { grid, temp, EL, COLORS, PARAM, draw };
  </script>
</body>
</html>
