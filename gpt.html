<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>物理沙盒 · 视觉编织场</title>
  <style>
    /* --- 视觉与排版（遵循用户的美学指引） --- */
    :root{
      --bg:#f7f8fa;
      --panel:#ffffff;
      --muted:#7a8691;
      --ink:#1f2a37;
      --accent:#2563eb;
      --soft:#eef2ff;
      --canvas-bg:#0f1220;
      --glass: rgba(255,255,255,0.6);
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, "PingFang SC", "Hiragino Sans GB", "Microsoft Yahei", "Helvetica Neue", Arial;
      background:linear-gradient(180deg,var(--bg) 0%, #eef3ff 100%);
      color:var(--ink);
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
      padding:32px;
      display:flex;
      justify-content:center;
      align-items:flex-start;
    }

    .stage {
      width:1100px;
      max-width:calc(100% - 48px);
      display:grid;
      grid-template-columns: 320px 1fr;
      gap:24px;
      align-items:start;
    }

    header {
      grid-column: 1 / -1;
      text-align:left;
      margin-bottom:6px;
    }

    h1{
      font-size:28px;
      line-height:1;
      margin:0 0 6px 0;
      font-weight:700;
      letter-spacing: -0.02em;
    }
    p.lead{
      margin:0;
      color:var(--muted);
      font-size:13px;
    }

    /* 左侧控制栏（呼吸为留白） */
    .controls {
      background:var(--panel);
      border-radius:14px;
      padding:18px;
      box-shadow:0 8px 30px rgba(18,30,50,0.06);
      display:flex;
      flex-direction:column;
      gap:12px;
    }

    .controls h3{
      margin:0 0 6px 0;
      font-size:14px;
      color:var(--ink);
    }

    .palette{
      display:grid;
      grid-template-columns:repeat(2,1fr);
      gap:8px;
    }
    .btn{
      border:0;
      padding:10px 12px;
      border-radius:10px;
      cursor:pointer;
      display:flex;
      gap:8px;
      align-items:center;
      font-weight:600;
      font-size:13px;
      color:white;
      box-shadow: 0 2px 8px rgba(16,24,40,0.06);
      transition: transform .12s ease, box-shadow .12s ease;
    }
    .btn:active{transform:scale(.99)}
    .btn.small{font-size:12px;padding:8px;border-radius:8px}
    .btn.toggled{outline:3px solid rgba(37,99,235,0.12); transform:translateY(-2px)}

    .e-water{background:linear-gradient(180deg,#4aa3ff,#2b7ed9)}
    .e-sand{background:linear-gradient(180deg,#f6b35b,#e08b2b)}
    .e-stone{background:linear-gradient(180deg,#a7afb6,#7f868b)}
    .e-wood{background:linear-gradient(180deg,#8b5a2b,#a86b3b)}
    .e-fire{background:linear-gradient(180deg,#ff6b4a,#e0422a)}
    .e-steam{background:linear-gradient(180deg,#dfe7ee,#ffffff); color:#1f2a37}
    .e-ice{background:linear-gradient(180deg,#bfe7ff,#9fd6ff); color:#05314a}

    .controls .row{display:flex;gap:8px;flex-wrap:wrap}
    .label{font-size:12px;color:var(--muted);margin-bottom:6px}

    .sliders{
      background:var(--soft);
      padding:10px;border-radius:10px;
      display:flex;flex-direction:column;gap:8px;
    }

    /* 画布面板（主屏幕占一题当令）*/
    .canvas-panel{
      background:var(--panel);
      border-radius:14px;
      padding:14px;
      box-shadow:0 8px 30px rgba(18,30,50,0.06);
      display:flex;
      flex-direction:column;
      gap:12px;
    }

    .canvas-top{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:8px;
    }
    .controls-compact{display:flex;gap:8px;align-items:center}
    .kbd{background:#111827;color:white;padding:6px 8px;border-radius:8px;font-size:12px}

    .canvas-wrap{
      background:var(--canvas-bg);
      border-radius:10px;
      padding:12px;
      display:flex;
      justify-content:center;
      align-items:center;
      position:relative;
      box-shadow: inset 0 1px 0 rgba(255,255,255,0.02);
    }

    canvas#sim {
      image-rendering: pixelated;
      border-radius:6px;
      background:linear-gradient(180deg,#0b0d14 0%, #101220 100%);
      box-shadow: 0 10px 30px rgba(7,10,20,0.6);
      display:block;
      max-width:100%;
      height:auto;
    }

    .legend{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
      font-size:12px;color:var(--muted)
    }
    .legend .item{display:flex;gap:8px;align-items:center;background:rgba(255,255,255,0.02);padding:6px 8px;border-radius:8px}
    .swatch{width:14px;height:14px;border-radius:3px;box-shadow: inset 0 -1px 0 rgba(0,0,0,0.2)}

    /* 说明面板 */
    .notes{
      grid-column:1 / -1;
      background:linear-gradient(180deg, rgba(255,255,255,0.9), rgba(255,255,255,0.96));
      border-radius:12px;padding:14px;color:var(--muted);font-size:13px;
      box-shadow:0 6px 20px rgba(16,24,40,0.04)
    }

    footer{margin-top:18px;text-align:center;color:var(--muted);font-size:12px}
    @media (max-width:980px){
      .stage{grid-template-columns:1fr; gap:12px}
      .controls{order:2}
      .canvas-panel{order:1}
    }
  </style>
</head>
<body>
  <main class="stage" aria-labelledby="title">
    <header>
      <h1 id="title">物理沙盒 · 视觉编织场</h1>
      <p class="lead">光与留白，张力与流——2D竖直切面物理沙盒。元素：水 / 沙 / 石 / 木（含植物特性） / 火 / 蒸汽 / 冰 —— 包含重力、热传导、状态变化与基本生态规律。</p>
    </header>

    <!-- 左：控制 -->
    <aside class="controls" aria-label="控制面板">
      <div>
        <h3>选择元素</h3>
        <div class="palette" role="list">
          <button class="btn e-water" data-el="water" role="listitem">💧 水</button>
          <button class="btn e-sand" data-el="sand" role="listitem">🌾 沙</button>
          <button class="btn e-stone" data-el="stone" role="listitem">🪨 石头</button>
          <button class="btn e-wood" data-el="wood" role="listitem">🪵 木材</button>
          <button class="btn e-fire" data-el="fire" role="listitem">🔥 火焰</button>
          <button class="btn e-steam" data-el="steam" role="listitem">☁️ 蒸汽</button>
          <button class="btn e-ice" data-el="ice" role="listitem">❄️ 冰</button>
        </div>
      </div>

      <div>
        <h3>画布控制</h3>
        <div class="row">
          <button id="eraseBtn" class="btn small" style="background:#6b7280">橡皮</button>
          <button id="clearBtn" class="btn small" style="background:#ef4444">清屏</button>
          <button id="pauseBtn" class="btn small" style="background:#2563eb">暂停</button>
        </div>
      </div>

      <div>
        <h3>参数</h3>
        <div class="sliders">
          <div class="label">重力：<span id="gravityVal">0.6</span></div>
          <input id="gravity" type="range" min="0" max="1.2" step="0.05" value="0.6">
          <div class="label">粒子尺寸（像素）：<span id="psizeVal">4</span></div>
          <input id="psize" type="range" min="2" max="8" step="1" value="4">
          <div class="label">环境温度（初始）：<span id="ambientVal">20</span> °C</div>
          <input id="ambient" type="range" min="-20" max="120" step="1" value="20">
        </div>
      </div>

      <div>
        <h3>提示</h3>
        <div style="color:var(--muted);font-size:13px;line-height:1.45">
          - 左键绘制所选元素；右键取样（按住 Shift 切换橡皮）。<br>
          - 新元素不会覆盖已有元素，会自动在最近空白处生成。<br>
          - 所有元素都会受重力影响落下，包括石头和木材。<br>
          - 木材融合了植物特性，需要水分维持，会消耗邻近水源；缺水时死亡。火焰可点燃木材。<br>
          - 冰会随温度转为水或蒸汽；适当降低粒子尺寸可获得更细腻的流体表现。
        </div>
      </div>
    </aside>

    <!-- 右：画布 -->
    <section class="canvas-panel" aria-label="模拟画布">
      <div class="canvas-top">
        <div>
          <strong>模拟画布</strong>
          <div style="font-size:12px;color:var(--muted)">竖直切面 · 2D 粒子格</div>
        </div>
        <div class="controls-compact">
          <div class="kbd" id="modeDisplay">模式：绘制</div>
          <div style="width:12px"></div>
          <div class="legend" aria-hidden="true">
            <div class="item"><div class="swatch" style="background:#4aa3ff"></div>水</div>
            <div class="item"><div class="swatch" style="background:#f6b35b"></div>沙</div>
            <div class="item"><div class="swatch" style="background:#a7afb6"></div>石</div>
            <div class="item"><div class="swatch" style="background:#8b5a2b"></div>木</div>
            <div class="item"><div class="swatch" style="background:#ff6b4a"></div>火</div>
            <div class="item"><div class="swatch" style="background:#dfe7ee"></div>蒸汽</div>
            <div class="item"><div class="swatch" style="background:#bfe7ff"></div>冰</div>
          </div>
        </div>
      </div>

      <div class="canvas-wrap" id="canvasWrap">
        <canvas id="sim" width="800" height="600" aria-label="物理沙盒画布"></canvas>
      </div>
    </section>

    <section class="notes" aria-label="说明">
      <strong>物理规则（摘要）</strong>
      <ul>
        <li>重力：所有元素都会受重力影响落下，包括石头和木材。</li>
        <li>热力：火焰提高周围温度；温度驱动相变：冰→水→蒸汽；蒸汽遇冷凝结为水。</li>
        <li>木材特性：融合了植物特性，需要水分维持生命，会消耗邻近水源；缺水时死亡。火焰可点燃木材。</li>
        <li>元素放置：新元素不会覆盖已有元素，会自动在最近的空白处生成。</li>
        <li>边界：画布四周为实物边界（最下方不可穿越，元素不能掉出画布）。</li>
      </ul>
    </section>

    <footer>设计 · 视觉编织场 — 以留白为氧，重要则大，流动有节</footer>
  </main>

  <script>
    /* ================= 优化说明（重点） =================
     - 使用扁平化栅格与 TypedArray（性能提升、减少 GC）
     - 将温度缓冲区复用，避免每帧分配大数组
     - BFS（最近空白）改为队列索引实现，避免 shift() 开销和大量字符串 visited
     - 在绘制与更新循环中缓存常量（减少属性查找）
     - 保持行为与原版接近，但显著降低每帧开销
    =================================================== */

    const canvas = document.getElementById('sim');
    const ctx = canvas.getContext('2d');

    // 动态参数（UI 更新）
    let PARAM = {
      particleSize: 4,
      gravity: 0.6,
      ambientTemp: 20,
      fpsLimit: 60
    };

    // 元素类型（使用小整数）
    const EL = {
      EMPTY: 0, SAND: 1, WATER: 2, STONE: 3, WOOD: 4,
      FIRE: 5, STEAM: 6, ICE: 7
    };

    const COLORS = {
      [EL.EMPTY]: '#0f1220',
      [EL.SAND]: '#f6b35b',
      [EL.WATER]: '#4aa3ff',
      [EL.STONE]: '#a7afb6',
      [EL.WOOD]: '#8b5a2b',
      [EL.FIRE]: '#ff6b4a',
      [EL.STEAM]: '#dfe7ee',
      [EL.ICE]: '#bfe7ff'
    };

    // 网格尺寸（cols, rows）与扁平化数组（index = x + y*COLS）
    let COLS = 0, ROWS = 0;
    let SIZE = 0; // COLS * ROWS

    // Typed arrays（复用）
    let grid;                // Uint8Array
    let temp;                // Float32Array
    let fireLife;            // Float32Array
    let woodHydration;       // Float32Array
    let woodWaterConsumed;   // Float32Array

    // 临时用于 diffusion 的缓冲区（复用）
    let newTemp;

    // 帮助：索引 / 边界
    const idx = (x,y) => x + y * COLS;
    const clampInt = (v, a, b) => Math.max(a, Math.min(b, Math.floor(v)));

    function allocGrid(){
      // 计算 COLS/ROWS 基于 canvas 的绘制像素大小与粒子尺寸
      COLS = Math.max(8, Math.floor(canvas.width / PARAM.particleSize));
      ROWS = Math.max(8, Math.floor(canvas.height / PARAM.particleSize));
      SIZE = COLS * ROWS;

      grid = new Uint8Array(SIZE);                 // 默认 0 (EMPTY)
      temp = new Float32Array(SIZE);
      fireLife = new Float32Array(SIZE);
      woodHydration = new Float32Array(SIZE);
      woodWaterConsumed = new Float32Array(SIZE);
      newTemp = new Float32Array(SIZE);

      // 初始化温度为环境温度
      for (let i = 0; i < SIZE; i++) temp[i] = PARAM.ambientTemp;
    }

    // 初始化
    // 注意：初始 canvas 宽高来自属性，resize 会重新配置 dpr 与栅格
    allocGrid();

    /* ========= UI 绑定（保持原样） ========= */
    const buttons = document.querySelectorAll('.palette .btn');
    let current = EL.SAND;
    const mapStrToEl = {sand:EL.SAND, water:EL.WATER, stone:EL.STONE, wood:EL.WOOD, fire:EL.FIRE, steam:EL.STEAM, ice:EL.ICE};
    const mapElToStr = Object.fromEntries(Object.entries(mapStrToEl).map(([k,v])=>[v,k]));

    buttons.forEach(b=>{
      b.addEventListener('click', ()=>{
        buttons.forEach(x=>x.classList.remove('toggled'));
        b.classList.add('toggled');
        const key = b.dataset.el;
        current = mapStrToEl[key] ?? EL.SAND;
      });
    });
    document.querySelector('.btn[data-el="sand"]').classList.add('toggled');

    const eraseBtn = document.getElementById('eraseBtn');
    const clearBtn = document.getElementById('clearBtn');
    const pauseBtn = document.getElementById('pauseBtn');
    const modeDisplay = document.getElementById('modeDisplay');

    let eraseMode = false;
    let paused = false;
    eraseBtn.addEventListener('click', ()=>{ eraseMode = !eraseMode; modeDisplay.textContent = eraseMode ? '模式：橡皮' : '模式：绘制'; eraseBtn.style.opacity = eraseMode ? '1' : '0.7' });
    clearBtn.addEventListener('click', ()=>{ allocGrid(); draw(); });
    pauseBtn.addEventListener('click', ()=>{ paused = !paused; pauseBtn.textContent = paused ? '继续' : '暂停'; });

    const gravitySlider = document.getElementById('gravity');
    const psizeSlider = document.getElementById('psize');
    const ambientSlider = document.getElementById('ambient');
    const gravityVal = document.getElementById('gravityVal');
    const psizeVal = document.getElementById('psizeVal');
    const ambientVal = document.getElementById('ambientVal');

    gravitySlider.value = PARAM.gravity; gravityVal.textContent = PARAM.gravity;
    psizeSlider.value = PARAM.particleSize; psizeVal.textContent = PARAM.particleSize;
    ambientSlider.value = PARAM.ambientTemp; ambientVal.textContent = PARAM.ambientTemp;

    gravitySlider.addEventListener('input', e=>{ PARAM.gravity = parseFloat(e.target.value); gravityVal.textContent = PARAM.gravity; });
    ambientSlider.addEventListener('input', e=>{ PARAM.ambientTemp = parseFloat(e.target.value); ambientVal.textContent = PARAM.ambientTemp; });
    psizeSlider.addEventListener('input', e=>{
      PARAM.particleSize = parseInt(e.target.value);
      psizeVal.textContent = PARAM.particleSize;
      allocGrid();
      draw();
    });

    /* ========= 鼠标绘制（保留原交互但更高效） ========= */
    let drawing = false;
    let last = null;

    function toCell(clientX, clientY){
      const rect = canvas.getBoundingClientRect();
      const cx = clientX - rect.left;
      const cy = clientY - rect.top;
      const col = clampInt(cx / PARAM.particleSize, 0, COLS - 1);
      const row = clampInt(cy / PARAM.particleSize, 0, ROWS - 1);
      return {col, row};
    }

    canvas.addEventListener('pointerdown', e=>{
      drawing = true;
      canvas.setPointerCapture?.(e.pointerId);
      if (e.button === 2) {
        const {col,row} = toCell(e.clientX, e.clientY);
        const value = grid[idx(col,row)];
        if (value !== undefined) {
          current = value || current;
          const key = mapElToStr[current];
          if (key){
            buttons.forEach(x=>x.classList.remove('toggled'));
            const btn = document.querySelector(`.btn[data-el="${key}"]`);
            if (btn) btn.classList.add('toggled');
          }
        }
      } else {
        handlePaint(e);
      }
    });
    canvas.addEventListener('pointermove', e=>{ if (drawing) handlePaint(e); });
    canvas.addEventListener('pointerup', e=>{ drawing = false; canvas.releasePointerCapture?.(e.pointerId); last = null; });
    canvas.addEventListener('contextmenu', e=> e.preventDefault());

    function handlePaint(e){
      const {col,row} = toCell(e.clientX, e.clientY);
      if (eraseMode || e.shiftKey) {
        paintBlock(col,row,EL.EMPTY);
      } else {
        paintBlock(col,row,current);
      }
      if (last){
        linePaint(last.col,last.row,col,row,current,(eraseMode|| e.shiftKey));
      }
      last = {col,row};
    }

    /* ========= 寻找最近空白（BFS 优化：队列索引 + 访问位图） ========= */
    function findNearestEmpty(sx, sy){
      const startI = idx(sx, sy);
      if (grid[startI] === EL.EMPTY) return {x: sx, y: sy};

      // 预分配队列（动态扩展），使用两个数组保存 x,y 或 index 形式
      const qx = new Int16Array(SIZE); // 可能浪费，但避免 push/shift
      const qy = new Int16Array(SIZE);
      let head = 0, tail = 0;

      const visited = new Uint8Array(SIZE);
      qx[tail] = sx; qy[tail] = sy; tail++;
      visited[startI] = 1;

      // 优先方向：下/左右/上
      const dirs = [[0,1],[1,0],[-1,0],[0,-1],[1,1],[-1,1],[1,-1],[-1,-1]];

      while (head < tail){
        const x = qx[head], y = qy[head]; head++;
        for (let i=0;i<dirs.length;i++){
          const nx = x + dirs[i][0];
          const ny = y + dirs[i][1];
          if (nx < 0 || nx >= COLS || ny < 0 || ny >= ROWS) continue;
          const ni = idx(nx, ny);
          if (visited[ni]) continue;
          if (grid[ni] === EL.EMPTY) return {x: nx, y: ny};
          visited[ni] = 1;
          qx[tail] = nx; qy[tail] = ny; tail++;
        }
      }
      return {x: sx, y: sy};
    }

    function paintBlock(cx, cy, el){
      const radius = Math.max(0, Math.floor(PARAM.particleSize / 2));
      for (let dx = -radius; dx <= radius; dx++){
        for (let dy = -radius; dy <= radius; dy++){
          const x = cx + dx, y = cy + dy;
          if (x < 0 || x >= COLS || y < 0 || y >= ROWS) continue;
          const i = idx(x,y);
          if (el === EL.EMPTY){
            grid[i] = EL.EMPTY;
            fireLife[i] = 0;
            woodHydration[i] = 0;
            woodWaterConsumed[i] = 0;
            continue;
          }
          if (grid[i] === EL.EMPTY){
            // 直接放置
            grid[i] = el;
            if (el === EL.FIRE) fireLife[i] = 120;
            if (el === EL.WOOD) { woodHydration[i] = 60; woodWaterConsumed[i] = 0; }
            if (el === EL.ICE) temp[i] = Math.min(temp[i], 0);
            if (el === EL.WATER) temp[i] = Math.max(temp[i], PARAM.ambientTemp);
          } else {
            // 找最近空白（小范围 BFS）
            const p = findNearestEmpty(x,y);
            const ni = idx(p.x, p.y);
            if (grid[ni] === EL.EMPTY){
              grid[ni] = el;
              if (el === EL.FIRE) fireLife[ni] = 120;
              if (el === EL.WOOD) { woodHydration[ni] = 60; woodWaterConsumed[ni] = 0; }
              if (el === EL.ICE) temp[ni] = Math.min(temp[ni], 0);
              if (el === EL.WATER) temp[ni] = Math.max(temp[ni], PARAM.ambientTemp);
            }
          }
        }
      }
    }

    function linePaint(x0,y0,x1,y1,el,isErase=false){
      const dx = Math.abs(x1-x0), dy = Math.abs(y1-y0);
      const sx = x0 < x1 ? 1 : -1, sy = y0 < y1 ? 1 : -1;
      let err = dx - dy;
      let x = x0, y = y0;
      while (true){
        paintBlock(x,y, isErase ? EL.EMPTY : el);
        if (x === x1 && y === y1) break;
        const e2 = 2 * err;
        if (e2 > -dy) { err -= dy; x += sx; }
        if (e2 < dx) { err += dx; y += sy; }
      }
    }

    /* ========= 物理规则（扁平化实现） ========= */
    const MELT_TEMP = 2;     // 冰→水
    const BOIL_TEMP = 90;    // 水→蒸汽
    const CONDENSE_TEMP = 50;// 蒸汽→水

    function swap(i1, i2){
      // swap grid
      const t = grid[i1]; grid[i1] = grid[i2]; grid[i2] = t;
      // swap temp & other state arrays
      const tt = temp[i1]; temp[i1] = temp[i2]; temp[i2] = tt;
      const f = fireLife[i1]; fireLife[i1] = fireLife[i2]; fireLife[i2] = f;
      const wh = woodHydration[i1]; woodHydration[i1] = woodHydration[i2]; woodHydration[i2] = wh;
      const wc = woodWaterConsumed[i1]; woodWaterConsumed[i1] = woodWaterConsumed[i2]; woodWaterConsumed[i2] = wc;
    }

    function inBounds(x,y){ return x >= 0 && x < COLS && y >= 0 && y < ROWS; }

    // 单帧更新（高频）
    function step(){
      // 1) 温度扩散（使用 newTemp 复用缓冲）
      const ambient = PARAM.ambientTemp;
      // 为性能，将常量缓存
      for (let i = 0; i < SIZE; i++) newTemp[i] = temp[i] * 0.6;

      // 推荐邻居权重：orthogonal 0.1 each
      for (let y = 0; y < ROWS; y++){
        const base = y * COLS;
        for (let x = 0; x < COLS; x++){
          let t = temp[base + x] * 0.6;
          let count = 0.6;
          // neighbors
          if (x+1 < COLS){ t += temp[base + x + 1] * 0.1; count += 0.1; }
          if (x-1 >= 0){ t += temp[base + x - 1] * 0.1; count += 0.1; }
          if (y+1 < ROWS){ t += temp[base + COLS + x] * 0.1; count += 0.1; }
          if (y-1 >= 0){ t += temp[base - COLS + x] * 0.1; count += 0.1; }
          t = t / count;
          t += (ambient - t) * 0.004;
          newTemp[base + x] = t;
        }
      }
      // swap buffers (copy back)
      for (let i = 0; i < SIZE; i++) temp[i] = newTemp[i];

      // 2) 元素更新：从下到上（避免覆盖导致重复移动）
      // 缓存一些常量
      const gs = PARAM.gravity;
      for (let y = ROWS - 2; y >= 0; y--){
        const base = y * COLS;
        const belowBase = (y + 1) * COLS;
        for (let x = 0; x < COLS; x++){
          const i = base + x;
          const el = grid[i];
          if (el === EL.EMPTY) continue;
          switch (el){
            case EL.SAND:
              updateSand(i, x, y, belowBase); break;
            case EL.WATER:
              updateWater(i, x, y, belowBase); break;
            case EL.ICE:
              updateIce(i, x, y, belowBase); break;
            case EL.FIRE:
              updateFire(i, x, y, base); break;
            case EL.STEAM:
              updateSteam(i, x, y); break;
            case EL.STONE:
              updateStone(i, x, y, belowBase); break;
            case EL.WOOD:
              updateWood(i, x, y, belowBase); break;
            default:
              break;
          }
        }
      }

      // bottom row fire handling
      const bottomY = ROWS - 1;
      const baseBot = bottomY * COLS;
      for (let x = 0; x < COLS; x++){
        const i = baseBot + x;
        if (grid[i] === EL.FIRE){
          fireLife[i] -= 4;
          if (fireLife[i] <= 0) { grid[i] = EL.EMPTY; fireLife[i] = 0; }
        }
      }
    }

    /* ---------- 各元素行为（基于索引） ---------- */

    function updateSand(i, x, y, belowBase){
      const belowI = belowBase + x;
      if (y + 1 < ROWS){
        const below = grid[belowI];
        if (below === EL.EMPTY || below === EL.STEAM || below === EL.WATER){
          swap(i, belowI); return;
        }
        // diagonal
        const dirs = Math.random() > 0.5 ? [1,-1] : [-1,1];
        for (let k=0;k<2;k++){
          const nx = x + dirs[k];
          if (nx>=0 && nx<COLS){
            const ni = belowBase + nx;
            const g = grid[ni];
            if (g === EL.EMPTY || g === EL.STEAM){ swap(i, ni); return; }
          }
        }
      }
    }

    function updateWater(i, x, y, belowBase){
      if (y + 1 < ROWS){
        const belowI = belowBase + x;
        const below = grid[belowI];
        if (below === EL.EMPTY || below === EL.STEAM){ swap(i, belowI); return; }
        const dir = Math.random() > 0.5 ? 1 : -1;
        if (x + dir >= 0 && x + dir < COLS){
          const ni = belowBase + (x + dir);
          const g = grid[ni];
          if (g === EL.EMPTY || g === EL.STEAM){ swap(i, ni); return; }
        }
        if (x - dir >= 0 && x - dir < COLS){
          const ni = belowBase + (x - dir);
          const g = grid[ni];
          if (g === EL.EMPTY || g === EL.STEAM){ swap(i, ni); return; }
        }
      }
      // horizontal spread
      if (Math.random() > 0.4){
        if (x + 1 < COLS && grid[i + 1] === EL.EMPTY){ swap(i, i + 1); return; }
      } else {
        if (x - 1 >= 0 && grid[i - 1] === EL.EMPTY){ swap(i, i - 1); return; }
      }
      // boil -> steam
      if (temp[i] >= BOIL_TEMP && Math.random() < 0.12){
        grid[i] = EL.STEAM;
        temp[i] += 8;
      }
    }

    function updateIce(i, x, y, belowBase){
      if (temp[i] >= MELT_TEMP){
        grid[i] = EL.WATER; return;
      }
      if (y + 1 < ROWS){
        const belowI = belowBase + x;
        const below = grid[belowI];
        if (below === EL.EMPTY || below === EL.STEAM || below === EL.WATER){ swap(i, belowI); return; }
        const dirs = Math.random() > 0.5 ? [1,-1] : [-1,1];
        for (let k=0;k<2;k++){
          const nx = x + dirs[k];
          if (nx>=0 && nx<COLS){
            const ni = belowBase + nx;
            const g = grid[ni];
            if (g === EL.EMPTY || g === EL.STEAM){ swap(i, ni); return; }
          }
        }
      }
    }

    function updateSteam(i, x, y){
      if (y - 1 >= 0){
        const upI = i - COLS;
        if (grid[upI] === EL.EMPTY){ swap(i, upI); return; }
      }
      if (Math.random() < 0.25){
        const dir = Math.random() > 0.5 ? 1 : -1;
        const nx = x + dir;
        if (nx >= 0 && nx < COLS && grid[i + dir] === EL.EMPTY){ swap(i, i + dir); return; }
      }
      if (temp[i] <= CONDENSE_TEMP && Math.random() < 0.05){
        grid[i] = EL.WATER; return;
      }
    }

    function updateFire(i, x, y, base){
      fireLife[i] -= 2;
      temp[i] += 12;
      // spread heat to neighbors
      const neighbors = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[-1,1],[1,-1],[-1,-1]];
      for (let n=0;n<neighbors.length;n++){
        const nx = x + neighbors[n][0], ny = y + neighbors[n][1];
        if (!inBounds(nx, ny)) continue;
        temp[idx(nx, ny)] += 6;
      }
      const topFactor = (y < ROWS * 0.15) ? 0.15 : 0.03;
      if (fireLife[i] <= 0 || Math.random() < topFactor){
        grid[i] = EL.EMPTY; fireLife[i] = 0; return;
      }
      // flame rises
      if (y - 1 >= 0){
        const upI = i - COLS;
        if (grid[upI] === EL.EMPTY){
          grid[upI] = EL.FIRE;
          fireLife[upI] = Math.max(20, fireLife[i] - 8);
          grid[i] = EL.EMPTY; fireLife[i] = 0; return;
        }
      }
      // horizontal / random spread
      let sideChance = (y < ROWS * 0.15) ? 0.08 : 0.28;
      if (Math.random() < sideChance){
        const dir = Math.random() > 0.5 ? 1 : -1;
        const nx = x + dir;
        if (nx >= 0 && nx < COLS && grid[i + dir] === EL.EMPTY){
          grid[i + dir] = EL.FIRE;
          fireLife[i + dir] = Math.max(20, fireLife[i] - 10);
          grid[i] = EL.EMPTY; fireLife[i] = 0; return;
        }
      }
      // interactions
      for (let n=0;n<neighbors.length;n++){
        const nx = x + neighbors[n][0], ny = y + neighbors[n][1];
        if (!inBounds(nx, ny)) continue;
        const ni = idx(nx, ny);
        const nearby = grid[ni];
        if (nearby === EL.WATER && Math.random() < 0.18){
          grid[ni] = EL.STEAM; temp[ni] += 18;
        } else if (nearby === EL.WOOD && Math.random() < 0.25){
          grid[ni] = EL.FIRE; fireLife[ni] = 140;
        } else if (nearby === EL.STONE){
          temp[ni] += 6;
        } else {
          if (nearby === EL.EMPTY && Math.random() < 0.02){
            grid[ni] = EL.FIRE; fireLife[ni] = 50;
          }
        }
      }
    }

    function updateStone(i, x, y, belowBase){
      if (y + 1 < ROWS){
        const belowI = belowBase + x;
        const below = grid[belowI];
        if (below === EL.EMPTY || below === EL.STEAM || below === EL.WATER){
          swap(i, belowI); return;
        }
        const dirs = Math.random() > 0.5 ? [1,-1] : [-1,1];
        for (let k=0;k<2;k++){
          const nx = x + dirs[k];
          if (nx>=0 && nx<COLS){
            const ni = belowBase + nx;
            const g = grid[ni];
            if (g === EL.EMPTY || g === EL.STEAM || g === EL.WATER){ swap(i, ni); return; }
          }
        }
      }
    }

    function updateWood(i, x, y, belowBase){
      // consumption rate（可调）
      const waterConsumed = 0.002;
      woodHydration[i] -= waterConsumed;
      // 吸水尝试
      const neighbors = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[-1,1],[1,-1],[-1,-1]];
      for (let n=0;n<neighbors.length;n++){
        const nx = x + neighbors[n][0], ny = y + neighbors[n][1];
        if (!inBounds(nx, ny)) continue;
        const ni = idx(nx, ny);
        if (grid[ni] === EL.WATER && Math.random() < 0.05){
          grid[ni] = EL.EMPTY;
          woodHydration[i] += 8;
          temp[ni] -= 2;
          break;
        }
      }
      woodWaterConsumed[i] += waterConsumed;
      // 当累积消耗达到 1，生长最多 2 个新木材
      if (woodWaterConsumed[i] >= 1){
        // 收集可能生长位置
        const possible = [];
        for (let n=0;n<neighbors.length;n++){
          const nx = x + neighbors[n][0], ny = y + neighbors[n][1];
          if (!inBounds(nx, ny)) continue;
          const ni = idx(nx, ny);
          if (grid[ni] === EL.EMPTY) possible.push(ni);
        }
        // 随机取最多2个
        if (possible.length > 0){
          for (let k = 0; k < Math.min(2, possible.length); k++){
            const pick = possible.splice(Math.floor(Math.random() * possible.length), 1)[0];
            grid[pick] = EL.WOOD;
            woodHydration[pick] = Math.max(0, woodHydration[i] * 0.8);
            woodWaterConsumed[pick] = 0;
          }
        }
        woodWaterConsumed[i] = 0;
      }
      if (woodHydration[i] <= 0){
        grid[i] = EL.EMPTY;
        woodHydration[i] = 0;
        woodWaterConsumed[i] = 0;
        return;
      }
      // 下落逻辑（类似石头/沙）
      if (y + 1 < ROWS){
        const belowI = belowBase + x;
        const below = grid[belowI];
        if (below === EL.EMPTY || below === EL.STEAM || below === EL.WATER){ swap(i, belowI); return; }
        const dirs = Math.random() > 0.5 ? [1,-1] : [-1,1];
        for (let k=0;k<2;k++){
          const nx = x + dirs[k];
          if (nx>=0 && nx<COLS){
            const ni = belowBase + nx;
            const g = grid[ni];
            if (g === EL.EMPTY || g === EL.STEAM || g === EL.WATER){ swap(i, ni); return; }
          }
        }
      }
      // 邻近火点燃
      for (let n=0;n<4;n++){
        const nx = x + neighbors[n][0], ny = y + neighbors[n][1];
        if (!inBounds(nx, ny)) continue;
        const ni = idx(nx, ny);
        if (grid[ni] === EL.FIRE && Math.random() < 0.35){
          grid[i] = EL.FIRE; fireLife[i] = 100; return;
        }
      }
    }

    /* ========= 绘制（使用扁平索引 + 行首缓存） ========= */
    function draw(){
      ctx.clearRect(0,0,canvas.width,canvas.height);
      const ps = PARAM.particleSize;
      ctx.fillStyle = '#0b0d14';
      ctx.fillRect(0,0,canvas.width,canvas.height);

      // 为了快速计算坐标，通过行循环并缓存 baseIndex
      for (let y = 0; y < ROWS; y++){
        const base = y * COLS;
        for (let x = 0; x < COLS; x++){
          const i = base + x;
          const el = grid[i];
          if (el === EL.EMPTY) continue;

          let col = COLORS[el] ?? '#ffffff';
          if (el === EL.FIRE){
            const life = Math.max(0, Math.min(fireLife[i], 160));
            const t = life / 160;
            const r = Math.floor(255 * (0.6 + 0.4 * t));
            const g = Math.floor(80 * (0.4 + 0.6 * t));
            const b = Math.floor(30 * (0.1 + 0.1 * t));
            col = `rgb(${r},${g},${b})`;
          } else if (el === EL.ICE){
            const tt = Math.max(0, Math.min((temp[i] + 20) / 120, 1));
            const mix = Math.floor(200 + 55 * (1 - tt));
            col = `rgb(${mix}, ${230}, ${255})`;
          } else if (el === EL.WATER){
            const tt = Math.max(-1, Math.min((temp[i] - PARAM.ambientTemp) / 60, 1));
            if (tt > 0.6) col = '#a7e0ff';
            else if (tt < -0.5) col = '#2a8bd6';
            else col = COLORS[el];
          } else if (el === EL.WOOD){
            const h = Math.max(0, Math.min(woodHydration[i] / 80, 1));
            const r = Math.floor(139 * (0.7 + 0.3 * (1 - h)));
            const g = Math.floor(90 * h + 50 * (1 - h));
            const b = Math.floor(43 * (0.5 + 0.5 * h));
            col = `rgb(${r},${g},${b})`;
          } else {
            col = COLORS[el];
          }

          ctx.fillStyle = col;
          ctx.fillRect(x * ps, y * ps, ps, ps);
        }
      }
    }

    /* ========= 主循环 ========= */
    let lastTime = performance.now();
    function tick(time){
      if (!paused){
        if (time - lastTime > (1000 / PARAM.fpsLimit)){
          step();
          draw();
          lastTime = time;
        }
      }
      requestAnimationFrame(tick);
    }
    requestAnimationFrame(tick);

    /* ========= 初始化种子（示范用） ========= */
    (function seed(){
      const base = ROWS - 1;
      for (let x=0;x<COLS;x+=2){
        if (Math.random() < 0.6){
          grid[base + x] = EL.STONE;
          temp[base + x] = PARAM.ambientTemp;
        }
      }
    })();

    /* ========= 处理高 DPI 与大小变化（更稳健） ========= */
    function resizeCanvas(){
      // 将 canvas 在视觉上拉伸到容器的大小，但使用 DPR 来提升细节
      const dpr = window.devicePixelRatio || 1;
      const rect = canvas.getBoundingClientRect();
      // 如果 rect.width/height 为 0，尝试使用属性或默认
      const cw = Math.max(200, rect.width || canvas.width || 800);
      const ch = Math.max(200, rect.height || canvas.height || 600);
      canvas.width = Math.floor(cw * dpr);
      canvas.height = Math.floor(ch * dpr);
      canvas.style.width = cw + 'px';
      canvas.style.height = ch + 'px';
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      allocGrid();
      draw();
    }

    function fitCanvasToContainer(){
      resizeCanvas();
    }
    // 立即适配
    fitCanvasToContainer();

    // 防止选中 canvas 文本
    document.addEventListener('selectstart', e => { if (e.target === canvas) e.preventDefault(); });
    window.addEventListener('resize', resizeCanvas);

    // 调试与外部访问点
    window._sim = { getGrid: () => grid, getTemp: () => temp, EL, COLORS, PARAM, draw };

  </script>
</body>
</html>
